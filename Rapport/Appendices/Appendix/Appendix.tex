%!TEX root = ../../Main.tex
\graphicspath{{Appendices/Appendix/}}
%-------------------------------------------------------------------------------


\begin{appendices}
\addtocontents{toc}{\protect\setcounter{tocdepth}{0}}
\renewcommand{\appendixname}{Appendiks}

\chapter{Arbejdsfordeling} \label{appendix::arbejdsfordeling}

Som resultat af gruppens relative lille størrelse, har begge parter været involveret i stort set alle arbejdsopgaver - herunder vidensdeling og interne diskussioner om afsnit i dokumentationen, samt udvikling af systemet. Herunder i tabel \ref{tab:arbejdsfordeling} ses der et samlet overblik over arbejdsfordelingen i de forskellige felter, for både dokumentationen, samt udviklingen af subsystemerne og blokkene herunder. Et grønt flueben antyder at personen har et dybdegående indblik i, og har har været højt involveret i udviklingen. Et gult flueben antyder et mindre kendskab og en mindre rolle i udviklingen.


\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{5.5cm} c  c }
		\multicolumn{3}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries Arbejdsfordeling} \\
		\kravHeaderStyle
		Arbejdsopgaver & Lasse Lildholdt & Philip Nygaard Schmidt \\
		
		Kravspecifikation & 
		\includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
		System arkitektur & 
		\includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
		Sampling - ConfigParser & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png}  \\
		
		Sampling - RTLSDRInterface & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
		Processing - DSP & 
		\includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Yellow_check.png} \\
		
		Processing - DBclientPC & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
		Storage - Webservice & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
		Storage - DatabaseInterface & \includegraphics[height=5mm]{img/8_Resultater/Yellow_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
		Presentation - Webfrontend & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
		Presentation - DBclientServer & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
		Tests & 
		\includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
		Dokumentation & 
		\includegraphics[height=5mm]{img/8_Resultater/Green_check.png} & \includegraphics[height=5mm]{img/8_Resultater/Green_check.png} \\
		
	\end{tabu}
	\caption{Oversigt over arbejdsfordelingen}
	\label{tab:arbejdsfordeling}
\end{table}


\chapter{Termliste} \label{appendix::termliste}

Herunder i tabel \ref{tab:termliste} og \ref{tab:termliste_fortsat} ses en oversigt over de termer der bliver brugt i dokumentationen for KMR systemet. Denne liste kan bruges af læseren, såfremt der skulle være tvivl om definitionen af et givent ord i dokumentationen.

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{4cm}  p{9cm}   }
		\multicolumn{2}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries Liste over termer} \\
		\kravHeaderStyle
		Navn: & Beskrivelse: \\
		
		KMR & Kamstrup Multichannel Receiver \\
		
		GMSK & Gaussian Minimum Shift Keying \\
		
		FSK & Frequency Shift Keying \\
		
		OQPSK & Orthogonal Quadrature Phase Shift Keying \\
		
		ASK & Amplitude Shift Keying \\
		
		ISI & Inter Symbol Inteference \\

		ACI & Adjecent Channel Inteference \\

		Syncword & Sekvens i pakkeindhold til synkronisering \\

		Preamble & Sekvens i pakkeindhold til indikaiton af ny pakke \\

		JSON & JavaScript Object Notation \\

		ADC & Anolog to Digital Converter \\

		DDC & Digital Down Conversion \\
		
	\end{tabu}
	\caption{Liste over termer brugt i dokumentationen}
	\label{tab:termliste}
\end{table}

\pagebreak
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{4cm}  p{9cm}   }
		\multicolumn{2}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries Liste over termer (fortsat)} \\
		\kravHeaderStyle
		Navn: & Beskrivelse: \\

		CRUD & Create, Read, Update and Delete (basic function of persistent storage) \\

		REST & Representational state transfer \\

		API & Application Programming Interface \\

		IOT4M & Ny trådløs Kamstrup protokol \\

		ISM & Industrial, Scientific and Medical \\ 

		PPM & Part per Million \\ 

		SCRUM & Agil arbejdsform \\ 

		FEC & Forward Error Correcion \\

		RF & Radio frequency \\

		IF & Intermediate frequency \\

		BB & Baseband \\ 

		DVB & Digital Video Broadcasting \\

		IQ samples & Komplekse samples (I = real del, Q = imaginær del) \\

		SDR & Software Defined Radio \\ 

		HTTP & HyperText Transfer Protocol \\

		CSS & Cascading Style Sheet \\

		HTML & HyperText Markup Language \\

		NRZ & Non Return to Zero \\

		PSD & Power Spectral Density \\

	\end{tabu}
	\caption{Liste over termer brugt i dokumentationen}
	\label{tab:termliste_fortsat}
\end{table}

\pagebreak

\chapter{ASE modellen} \label{appendix::asemodellen}
ASE modellen i figur \ref{fig:asemodellen} er blevet introduceret i forhenværende semester projekter på ASE, Aarhus School of Engineering. Denne giver en struktureret model for udvikling af et kommende system, hvori der både er inkluderet hardware og software.

\begin{figure}[H]
	\centering
	\includegraphics[width = 350 pt]{img/9_Appendices/ASEmodellen.PNG}
	\caption[ASE modellen]{ASE modellen - Kilde: Kim Bjerg - Vejledning til udviklingsprocessen}
	\label{fig:asemodellen}
\end{figure}

\pagebreak

\chapter{Tidsplan} \label{appendix::tidsplan}
I forbindelse med udførelsen af projektet blev der fra start defineret en tidsplan. Denne indeholder de faser der oprindeligt blev defineret for projektet, samt en estimering af hvilke uger i projektforløbet der allokeres til hvilke faser af projektet. Tidsplanen er revideret mange gange undervejs i projektforløbet, og har i flere tilfælde heller ikke kunne holde, hvorfor der er foretaget omstrukturering i ugeallokeringen.

På figur \ref{fig:tidsplan} ses en visualisering af tidsplanen, samt et overblik over hvilke uger der har været brugt på reviews. Det ses her tydeligt hvordan reviews har været brugt i store perioder på at redefinerer moduldesigns som følge af de testresultater der har været. Det er i processerer som denne, hvor iterativ udvikling har været nødvendig, at tidsplanen har været anvendt til at holde styr på den resterende tid af projektforløbet.  

\begin{figure}[H]
	\centering
	\includegraphics[width = 350 pt]{img/9_Appendices/tidsplan.PNG}
	\caption[Tidsplan]{Tidsplan for udførelse af KMR systemet og projektet}
	\label{fig:tidsplan}
\end{figure}

\pagebreak

\chapter{Sekvensdiagrammer til visualisering af usecases} \label{appendix::sequence_usecases}

Af tabel \ref{table:use_case_1_sample_data}, \ref{table:use_case_2_process_data} og \ref{table:use_case_3_present_data}, visende systemets usecases, findes information om hvorledes systemet agerer i forhold til at yde den funktionalitet der ligger i systemet. For at visualisere denne ageren, samt den interaktion der i mellem KMR systemet og de henholdsvis initialiserende og eksterne aktører, vil der i dette afsnit præsenteres sekvensdiagrammer for de enkelte usecases. 

\subsubsection{Sekvensdiagram usecase 1 - Sample data}

Af figur \ref{fig:sekvens_diagram_uc1}, ses sekvensdiagrammet for usecase 1. Der er 2 aktive aktører i denne, hvilket er den initialiserende aktør "Bruger" og den eksterne aktør "RTL-SDR", da KMR systemet skal startes og at systemet skal benytte sig af RTL-SDR'en for at kunne sample.

\begin{figure}[H]
	\centering
	\includegraphics[width = 300 pt]{img/3_Specifikationer/sekvens_uc1.pdf}
	\caption[Sekvensdiagram usecase 1]{Sekvensdiagram - visualisere flowet gennem usecase 1}
	\label{fig:sekvens_diagram_uc1}
\end{figure}

\subsubsection{Sekvensdiagram usecase 2 - Process data}

Af figur \ref{fig:sekvens_diagram_uc2}, ses sekvensdiagrammet for usecase 2. Der er 2 aktører som interagerer med systemet. Brugeren får undervejs i usecasen status på eventuelle fejl, samt hvorvidt om usecasens hovedscenarie er gennemført succesfuldt. Herudover er Databasen også en aktør, da KMR systemet skal uploade data til denne.

\begin{figure}[H]
	\centering
	\includegraphics[width = 300 pt]{img/3_Specifikationer/sekvens_uc2.pdf}
	\caption[Sekvensdiagram usecase 2]{Sekvensdiagram - visualisere flowet gennem usecase 2}
	\label{fig:sekvens_diagram_uc2}
\end{figure}

\pagebreak

\subsubsection{Sekvensdiagram usecase 3 - Present data}

Af figur \ref{fig:sekvens_diagram_uc3}, ses sekvensdiagrammet for usecase 3. Her ses 3 forskellige aktører, udover KMR systemet; Brugeren, som initialiserer usecasen, Browseren, som bruges som fremvisningværktøj imellem brugeren og de resterende aktører, samt Databasen, som indeholder dataene som skal fremvises for brugeren igennem Browseren.

\begin{figure}[H]
	\centering
	\includegraphics[width = 300 pt]{img/3_Specifikationer/sekvens_uc3.pdf}
	\caption[Sekvensdiagram usecase 3]{Sekvensdiagram - visualisere flowet gennem usecase 3}
	\label{fig:sekvens_diagram_uc3}
\end{figure}

\chapter{Study cases} \label{appendix::studycases}

\section{Pakke indhold} \label{appendix::studycase::pakke_indhold}
I afsnittet for yderligere krav til systemet i Specifikations-afsnittet i rapporten, nærmere betegnet: krav (6.1), (6.2), (6.3), (6.4) og (6.5), bliver der stillet krav til indholdet af pakkerne, samt struktureringen og indholdet af data-objekter som bliver konstrueret ud fra pakke-indholdet i de modtagende signaler. Derfor er det en nødvendighed at have overblik over pakkeindholdet i de trådløse signaler, således at strukturen og indholdet af de konstruerede data-objekter i systemet er korrekte. 

Herunder i figur \ref{fig:pakke_struktur}, ses et udleveret billede fra Kamstrup, visende den nye protokol til de kommende prototyper af målere, som systemet er beregnet til at teste på. Det er, i forhold til at forstå denne pakke struktur, nødvendigt at kende til den kodning som pakken normalt er underlagt. Her anvendes FEC code (Forward Error Correction), som generelt har brug for parity bits og termination bits. I Kamstrups pakkestruktur er headeren og dataframen separat FEC kodet, hvorfor der er brug for to sæt af paritet og terminerings bits (1 sæt til header og 1 sæt til dataframe).  

\begin{tabular}{ p{3cm} | p{9cm} }
	Preamble & Preamble bruges som startsekvens for kommende transmission. I dette tilfælde en 96 bit serie af 0 og 1.  \\ \\

	Synch. & Syncword som bruges til at indikere slutningen på headeren og dermed indikation på at selve dataene i pakken kommer efterfølgende. På denne måde kan der synkroniseres ved hjælp af syncordet. \\ \\
	
	Delimiter & Delimiter er udelukkende slutningen på headeren og den sidste indikation på den kommende data. \\ \\
	
	Length(L) & Dataframe længden. \\ \\
	
	Parity-Header &  Paritetsbits til header FEC kode.\\ \\
	
	CTRL\_c &  Typen af FEC kodning til dataframe. \\ \\
	
	Term. Header & Termination bits til header FEC kode. \\ \\
	
	CTRL\_ef &  Raten af FEC kode til dataframe. \\ \\
	
	Term. DataFrame &  Terminations bits til dataframe FEC kode.\\ \\
	
	Dataframe &  Pakkeindhold. \\ \\
	
	CRC16 &  16 bit integritets check. \\ \\
	
	Parity DataFrame &  Paritetsbits til dataframe FEC kode. \\ \\
\end{tabular}

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/physical_layer_frame.png}
	\caption{Pakke struktur}
	\label{fig:pakke_struktur}
\end{figure} 

\pagebreak
\section{RTL-SDR} \label{appendix::studycase::rtlsdr}
Som følge af krav (4.1) er det givet at KMR systemet skal virke, ved brug af enheden RTL2832U med chippen R820T2 \cite{RTLSDR}. Enheden vil i det følgende blot benævnes som RTL-SDR. Denne enhed er leveret af Kamstrup, og i forbindelse med udviklingen af kravspecifikationen, blev det fastlagt at systemet skal være funktionelt ved brug af denne enhed. 

\subsection{Interface}
For at kunne anvende enheden, er det nødvendigt først at undersøge, hvorledes der fra KMR systemet, kan interfaces til denne eksterne aktør. Som det tidligere er beskrevet skal KMR systemet fungere som en software defined radio, hvorfor der i søgningen efter interface muligheder til RTL-SDR enheden, bruges denne kobling mellem RTL-SDR enheder og software defined radio principper \cite{SDR}. 

Netop til denne kobling findes et bibliotek udviklet i sproget C, kaldet librtlsdr \cite{librtlsdr}. Dette bibliotek tilbyder funktionalitet der sammen med DVB enheder kan lave en SDR modtager. KMR projektets RTL-SDR enhed er netop en DVB enhed, grundet den chip der sidder på enheden fungerer, ved brug af en DVB-T tuner. Når det nævnes at enheden kan tilbyde funktionalitet som en SDR modtager, betyder det i virkeligheden at der kan samples radiosignaler og ud fra dette leveres rå IQ samples. Disse samples danner basis for den software, der definere en software defined radio, idet der kan laves signalbehandling på disse. 

Biblioteket librtlsdr, er som sagt udviklet i C. Ud fra kravene er det givet at KMR systemet skal designes og implementeres i udviklingssproget Python. Det vil derfor ikke direkte være muligt at anvende librtlsdr biblioteket. Der findes dog en udvidelse til Python kaldet "c-types" som tillader at anvende C funktioner internt i Python. Dette bruges til at lave wrappere til C biblioteker således at de kan anvendes i Python. 

Netop dette er gjort for librtlsdr i en wrapper kaldet pyrtlsdr \cite{pyrtlsdr}. Denne wrapper alle funktioner i C biblioteket ved hjælp af c-types, og tillader derfor funktionskald fra Python til wrapperen. Dette opfylder netop de krav der findes til interfacet til RTL-SDR enheden. En illustration af sammenhængen mellem RTL-SDR enhed, librtlsdr og pyrtlsdr ses af figur \ref{fig:rtlsdr_bib}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 300 pt]{img/4_Studycases/rtlsdr.pdf}
	\caption{RTL-SDR enhed med tilhørende biblioteker}
	\label{fig:rtlsdr_bib}
\end{figure} 

\pagebreak
\subsection{Configparser} \label{appendix::studycase::configparser}

Med udgangspunktet i krav om at brugeren skal kunne angive indstillinger til systemet, er der lagt op til at researche, hvordan dette ville kunne realiseres.

Python modulet, configparser (Configuration File Parser) \cite{configparser}, tilbyder netop denne funktionalitet. Dette modul er blevet lavet på baggrund af Microsoft Windows INI filer, som typisk bliver brugt til angivelse af indstillinger til programmer. Configparser modulet kan indsamle indstillinger fra INI filen til en given applikation, og gøre brug af disse i applikationen. Hermed kan brugerens indtastede værdier indhentes af programmet og bruges senere, i samme program eller applikation.

INI-filen som benyttes af configparser modulet skal derfor i forbindelse med KMR systemet indeholde alle de indstillingsparametre, der er nødvendige for den korrekte opsætning, i forhold til de definerede krav. En given opsætning for KMR systemet, gennem configparseren ses herunder:

[DEFAULT] \newline \newline
CHANNELS\_TO\_SAMPLE = 12345678 \newline
CENTER\_FREQUENCY\_CHANNEL\_1 = 866.7 \newline
CENTER\_FREQUENCY\_CHANNEL\_2 = 866.9 \newline
CENTER\_FREQUENCY\_CHANNEL\_3 = 867.1 \newline
CENTER\_FREQUENCY\_CHANNEL\_4 = 867.3 \newline
CENTER\_FREQUENCY\_CHANNEL\_5 = 867.5 \newline
CENTER\_FREQUENCY\_CHANNEL\_6 = 867.7 \newline
CENTER\_FREQUENCY\_CHANNEL\_7 = 867.9 \newline
CENTER\_FREQUENCY\_CHANNEL\_8 = 868.1 \newline
SAMPLE\_FREQUENCY = 2500000 \newline
MODULATION\_TYPE = GMSK \newline
DEVIATION\_FREQUENCY = 10000
SYNCWORD = 0x91B39CEB \newline
SYNCWORD\_LENGTH = 32 \newline
PAYLOAD\_LENGTH = 32 \newline
RECEIVING\_TIME = 1 \newline
FREQUENCY\_CORRECTION = 60 \newline

\pagebreak
\subsection{Opbygning}
I normale modtager systemer til brug indenfor radio, anvendes ofte én af 3 typer af arkitekturer. Disse arkitekturer kan alle anvendes, for at opnå et system der kan sample de meget hurtige signaler der transmitteres indenfor mange radio-domæner. Som det ses af krav (7.1) skal KMR systemet sample signaler beliggende omkring 868 MHz. 

De arkitekturer der normalt benyttes til disse modtager systemer, vil hver behandles i det følgende. Dette vil give en viden der tillader os at undersøge opbygningen af RTL-SDR enheden til KMR systemet, og dermed undersøge hvorledes denne kan anvendes til at sample de signaler, der er nødvendige for systemet.

\subsubsection{Heterodyne Receiver}
En heterodyne modtager bygger på en arkitektur, der anvender en mixer til nedkonvertering af det indkommende signal \cite{receiver-architecture}. Dette gøres for at kunne sænke den frekvens der vil være på det indkommende signal, inden dette føres videre i behandlingen.Man vil typisk gerne gøre dette, da det sænker performance kravene til de følgende stadier i signalbehandlingen. Før mixer stadiet i en heterodyne receiver, siges det at signalet befinder sig på RF (radio frequency). Efter mixer stadiet har man mixet signalet ned i frekvens, hvorfor det siges at befinde sig på IF (intermediate frequency). Dette IF signal kan ledes videre til eksempelvis en demodulator, der herefter kan trække signal ned til BB (baseband) og indhente dataene fra signalet. En illustration af en heterodyne arkitektur kan ses af figur \ref{fig:heterodyne}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 300 pt]{img/4_Studycases/heterodyne.pdf}
	\caption{Eksempel på heterodyne modtager arkitektur}
	\label{fig:heterodyne}
\end{figure} 

\pagebreak
\subsubsection{Super Heterodyne Receiver}
En super heterodyne modtager fungerer i store træk ligesom den normale heterodyne modtager \cite{receiver-architecture}. Den adskiller sig ved, hvor den normale heterodyne modtager kun har et mixer trin til at trække signalet fra RF ned til IF, at have to mixer stadier. Dette kan både give nogle ulemper og fordele. Fordelen ligger primært i at der med to mixer stadier kan realiseres en lavere lokal oscillator frekvens til de enkelte mixer trin. Dette kan ofte være billigere at realisere. Ulempen ligger selvfølgelig i at der her skal anvendes en komponent ekstra, hvilket hæver prisen på en potentiel produktion af modtageren. En illustration af en super heterodyne arkitektur kan ses af figur \ref{fig:super_heterodyne}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 300 pt]{img/4_Studycases/super_heterodyne.pdf}
	\caption{Eksempel på super heterodyne modtager arkitektur}
	\label{fig:super_heterodyne}
\end{figure} 

\subsubsection{Homodyne Receiver}
Den homodyne modtager er den simpleste arkitektur \cite{receiver-architecture}. Denne anvender ikke nogen mixer trin med lader RF signalet være direkte input for den videre signal behandling, eksempelvis demodulering. Dette gør at den nedkonvertering i frekvens der ligger i demodulatoren, skal have en lokal oscillator der skal have en frekvens lig med RF signalet. Dette kan i nogle situationer være fordelagtigt, hvis RF frekvensen ikke er for høj og man formår at implementere demoduleringsstadiet således der undgås for meget LO leakage (LO leakage forklares i det følgende afsnit). En illustration af homodyne arkitekturen kan ses af figur \ref{fig:homodyne}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 200 pt]{img/4_Studycases/homodyne.pdf}
	\caption{Eksempel på homodyne modtager arkitektur}
	\label{fig:homodyne}
\end{figure} 

\subsubsection{Valg af modtager arkitektur}
Når man skal vælge en modtager arkitektur, kommer det meget an på det pågældende system eller applikation man skal designe og udvikle, jævnfør eventuelle krav. Hvad ligger RF niveauet på, hvordan ser ens implementering af mixer trin ud, og hvor meget LO leakage kan man leve med. \newline
LO leakage er et fænomen der opstår når man implementerer en mixer. Ideelt set ville man med et mixer trin gerne opnå at outputtet af dette trin, vil være henholdsvis ligning \ref{mixer1} og \ref{mixer2}.

\begin{equation} \label{mixer1}
F_{RF} + F_{LO}
\end{equation}

\begin{equation} \label{mixer2}
F_{RF} - F_{LO}
\end{equation}

hvor F\_LO er den lokal oscillator der bruges til mixer trinnet. Dette vil dog være det ideelle tilfælde. Med en reel implementering ville man typisk også se at både input frekvensen og LO frekvensen vil være til stede efter mixer trinnet \cite{lo-leakage}. En illustration af dette fænomen ses af figur \ref{fig:realmixer}, der viser fænomenet ved en op mixing af et BB signal, mens det af figur \ref{fig:idealmixer} ses hvordan den ideelle situation ville se ud.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/idealmixer.pdf}
	\caption{Ideelt mixer stadie til op mixing af BB signal}
	\label{fig:idealmixer}
\end{figure} 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/realmixer.pdf}
	\caption{Reelt mixer stadie til op mixing af BB signal}
	\label{fig:realmixer}
\end{figure} 

Dette fænomen leder til brugen af heterodyne og super heterodyne modtager arkitekturer. Med en sådan arkitektur vil de LO frekvenser der anvendes i mixer stadierne ikke ligge i nærheden af RF signalet. Dette vil gøre at potentiel LO leakage ikke tages med i signalet, der ledes videre til demodulering. For at rekapitulere: LO frekvensen i den homodyne modtager arkitektur er lig med frekvensen på RF signalet. Derfor vil den potentielle LO leakage også ligge indenfor RF signalet efter mixer trinnet. 

\pagebreak
\subsubsection{RTL-SDR modtager arkitektur}
Med ovenstående viden om modtager arkitekturer kan der hermed ses på RTL-SDR enheden og dennes modtager arkitektur \cite{rtlsdr-architecture}. En illustration af modtager arkitekturen for RTL-SDR enheden kan ses af figur \ref{fig:rtlsdr_arc}. Det ses af denne at der i første stadie ligger en analog mixer. Dette leder os hen imod en heterodyne modtager arkitektur. Dog ses der også en DDC, digital down conversion blok, efter ADC'en. Denne blok fungerer ligesom mixeren - blot i det digitale domæne. Derfor kan arkitekturen på en måde tolkes som en super heterodyne modtager arkitektur idet der faktisk er et mixer stadie mere, om end dette er digitalt. Der kan være fordele ved dette digitale mixer stadie i det man i det digitale domæne ofte kan realisere skarpere filtre - i forhold til det analoge domæne. Dette kan være en af grundene til at arkitekturen ser ud som den gør. En af ulemperne ved denne model med et digitalt mixer trin er at ADC'en skal fungere ved den første IF frekvens, hvilket vil sige den skal sample hurtigere end hvis det andet mixer trin havde ligget forinden. Derfor vil en hurtigere ADC være nødvendig for denne arkitektur. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/rtlsdr_arc.png}
	\caption{Modtager arkitektur for RTL-SDR enhed}
	\label{fig:rtlsdr_arc}
\end{figure} 

Det kan altså konkluderes at RTL-SDR enheden har en (super) heterodyne modtager arkitektur. Dette vil sige at RTL-SDR enheden sagtens kan sample de signaler der ønskes i ISM båndet, da den har et analogt mixer trin der kan trække disse signaler ned til en IF frekvens. Det er LO frekvensen på denne analoge mixer der afgør hvor højt oppe i frekvens RTL-SDR enheden kan sample signaler. Der vides dog, af data-bladet for enheden, at den maksimale samplerate der kan bruges med enheden er 2.56 MSPS (mega samples pr sekund). Denne begrænsning burde ikke være der, idet der med denne modtager arkitektur sagtens kan sample hurtigere. ADC'en skal som sagt sample ved den første IF frekvens, hvilket ligger ved 3.57 MHz. Flaskehalsen ligger her i stedet i USB interfacet der er integreret i enheden, som skal levere samples videre. USB 2.0 standarden har en begrænsning i hastighed som diktere flaskehalsen i denne sammenhæng. Derfor er det maksimale antal samples der kan hives ud af enheden, som implementer et USB 2.0 interface, altså disse 2.56 MSPS hvis der ikke ønskes at tabe samples i USB overførslen.

\pagebreak

\section{Channelizer} \label{appendix::studycase::channelizer}
Som følge af den kravspecifikation der er opstillet for KMR systemet er det givet, at systemet skal kunne håndtere 8 kanaler simultant, kun ved brug af en enhed til sampling. Dette gøres ved at der samples over en båndbredde, der indeholder samtlige af de kanaler der transmitteres på, hvorefter disse samples manipuleres således at hver enkel kanal kan pilles ud og demoduleres for sig. 

Under normale omstændigheder ville dette gøres ved at bruge en kompleks mixer, bestående af en indfase og en quadrature fase komponent med en LO (lokal oscillator) frekvens svarende til kanalfrekvensen. Herefter vil den givne kanal være trukket ned til DC, og et lavpas filter med en cuttoff frekvens svarende til dataraten på kanalen vil herefter kunne bruges, til at fjerne de resterende kanaler. Dette er en særdeles brugbar metode, men samtidig en krævende proces, idet både mixeren og filteret kræver en del matematiske operationer. Når kanalen mixes til DC vil den samplerate, der anvendes for at fange kanalen, typisk være alt for høj og unødvendige samples ryger dermed med i processeringen. Derfor ønsker man typisk at decimere signalet efter det er mixet ned. Dette er også muligt med førnævnte metode, men store decimeringer kræver hurtige mixere og meget lange filtre - noget der typisk ikke ønskes i en realtids modtager. 

For at lave denne decimering på en mere effektiv måde, er CIC filtre introduceret. Dette filter er en måde hvorpå store decimeringer kan opnås, uden brug af gange operationer, hvorfor denne er meget effektiv. Derudover er der en del flere fordele ved filteret, som behandles i det følgende. 

I det følgende vil CIC filtre analyseres, og det vil undersøges hvorledes disse kan anvendes i forbindelse med KMR systemet. Viden omkring CIC filtre findes fra henholdsvis \cite{CIC-compensation} og \cite{CIC-filters}.

Et CIC filter har altså til formål, at lave en decimering (eller en interpolation) af et signal. Man kan ikke blot decimere et signal, idet du derved sænker samplefrekvensen og dermed potentielt trækker denne ned under Nyquist frekvensen. Derfor er det nødvendigt først at lægge et lavpas filter ind, med en cuttoff frekvens svarende til nykvist frekvensen, i forhold til den nye samplefrekvens efter decimeringen. En sådan proces vil se ud som den vist på figur \ref{fig:cic_decimering}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/cic_start.png}
	\caption{Potentiel decimerings sekvens}
	\label{fig:cic_decimering}
\end{figure} 

I denne sammenhæng vil h(z) altså være det lavpas filter, der er nødvendigt for decimeringen. Dette vil dog ikke være den bedste fremgangsmåde i forhold til decimeringen, idet filteret vil skulle virke på den samplefrekvens der er til stede inden decimeringen. Denne vil typisk være meget høj (indenfor radio-domænet), hvilket vil sige filteret vil agere meget langsomt. 

For at lave en anden tilgang til denne metode at lave decimering på, er det nødvendigt først at se på CIC filteret transfer funktion. CIC filteret består som benævnt af en række integrator og comb stadier. Sættes disse to i forlængelse af hinanden fungerer de som et moving average filter. Dette vil sige at hvert output af filteret, genereres som en midling af de sidste R * M input samples (R er decimerings faktoren, mens M er det diffenretielle delay til comb filteret). En transfer funktion for N versioner af et sådant moving average filter vil se ud som ligning \ref{CIC_transfer}.   

\begin{equation} \label{CIC_transfer}
h(z) = (\frac{1 - z^{-RM}}{1 - z^{-1}})^N
\end{equation}

Ved at faktorisere transfer funktionen for moving average filteret, fås ligning \ref{CIC_transfer_factorized}. Her ses to komponenter, den første del svarer til transfer funktionen for en integrator, hvorimod anden del svarer til transfer funktion for et comb filter. Integratoren summerer det nuværende input med de tidligere output, mens comb filteret trækker en forsinket version af inputtet fra det nuværende input. Forsinkelsen i comb filteret, kaldes det differentielle delay. 

\begin{equation} \label{CIC_transfer_factorized}
h(z) = (\frac{1}{1 - z^{-1}})^N * (1 - z^{-RM})^N
\end{equation}

Det er her værd at notere sig, hvordan kun comb stadiet afhænger af decimeringsfaktoren R og det differentielle delay M. Derfor kan denne del af filteret rykkes til efter decimeringen, og derved operere ved en den nye lavere samplefrekvens. Dette vil resultere i N blokke af integratorer før decimeringsstadiet, og N blokke af comb filtre efter decimeringsstadiet. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/cic_transfer.png}
	\caption{CIC filter med transfer funktioner}
	\label{fig:cic_transfer}
\end{figure} 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/cic_transfer_block.png}
	\caption{CIC filter blok diagram}
	\label{fig:cic_transfer_block}
\end{figure} 

På denne måde genereres et filter, der decimerer et inputsignal, mens det samtidig lavpas filtrerer i forhold til den nye samplefrekvens. Der er dog en række aspekter omkring CIC filtre, der kan give anledning til problemer. For at illustrere dette antages et eksempel: Et signal med en samplefrekvens på 10 MHz ønskes decimeret til 625 KHz. Dette kræver en decimering på R = 16. Et CIC filter med decimeringsfaktor 16, en orden (antal af integrator og comp blokke) på 5 og en differentielt delay på 1, er plottet på figur \ref{fig:cic_no_fir}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/cic_no_fir.pdf}
	\caption{CIC filter med forvrænget pasbånd}
	\label{fig:cic_no_fir}
\end{figure} 

Den røde linje på billedet viser nykvist frekvensen ved den nye samplefrekvens på 625 KHz, altså er den beliggende ved 312.5 KHz. Ideelt set skulle der med denne samplefrekvens kunne samples alle signaler der ligger indenfor de 312.5 KHz. Det er dog værd at bemærke hvordan der på det højre billede, kan ses at pasbåndet indenfor de 312.5 KHz her kan forvrænge signalet med op til 20 dB såfremt signalet ligger helt op ad Nyquist frekvensen. Man ville her kunne ønske sig at pasbåndet var helt fladt, og dermed uden forvrængning. 

Måden dette løses på er ved at lave et kompenseringsfilter, der sættes i forlængelse af CIC filteret. Dette filter skal derfor have et respons i pasbåndet, der netop løfter den forvrængning der ellers er at finde for CIC filteret. Det er dog værd at nævne et andet problem omkring CIC filtre - Dæmpningen af signalet omkring Nyquist frekvensen ikke er særlig høj. De 20 dB der ses af \ref{fig:cic_no_fir}, er ganske vist et problem, fordi dæmpningen starter tidligt i pasbåndet, men man ønsker generelt en højere dæmpning en 20 dB omkring Nyquist frekvensen. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/cic_with_fir.pdf}
	\caption{CIC filter med bredt kompenseret pasbånd}
	\label{fig:cic_with_fir}
\end{figure} 

Af figur \ref{fig:cic_with_fir}, ses det hvordan kompenseringsfilteret hæver pasbåndet. Såfremt det lægges i forlængelse af CIC filteret, vil pasbåndet opnå en fladere profil uden forvrængning. Det ses dog af samme figur problemet omkring dæmpningen nær Nyquist frekvensen. På figur \ref{fig:cic_with_fir} er pasbåndet defineret meget bredt, hvorfor kompenseringsfilteret faktisk går ind og sænker dæmpningen nær Nyquist frekvensen. Hvad man typisk i stedet ønsker er, at definere pasbåndet for kompenseringsfilteret noget mere smalt. Dermed opnår man i stedet en forhøjet dæmpning omkring nykvist frekvensen, samtidig med et fladt pasbånd opnås, omend dette er smallere. Et sådant eksempel kan ses af figur \ref{fig:cic_with_fir_narrow}. Der ses her hvordan dæmpningen nær Nyquist frekvensen er hævet til omkring 100 dB, hvilket sikrer at der ikke opstår alias problemer.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/cic_with_fir_narrow.pdf}
	\caption{CIC filter med smalt kompenseret pasbånd}
	\label{fig:cic_with_fir_narrow}
\end{figure} 

\subsection{I og Q separering}
Jævnfør kravene skal et eventuelt CIC filter, samt andre eventuelle implementeringer, designet og implementeres i Python. Dette medfører at dataene skal behandles som integers. Der vælges i dette tilfælde at bruge unsigned integers. Dette skaber dog problemer i og med CIC filteret som bekendt skal virke på de komplekse samples der leveres fra den eksterne RTL-SDR enhed. For at kunne behandle disse komplekse samples findes det nødvendigt at opdele input signalets reelle del og imaginære del, til hver deres input. Disse vil så skulle behandles hver for sig, hvorefter de samles igen efter behandlingen. 

\pagebreak
\subsection{Bit growth for CIC filtre i Python}
Når man ser på CIC filtre er det vigtigt at notere sig, at der er et gain involveret med filteret. Dette gain kan udtrykkes som i ligning \ref{CIC_gain}. 

\begin{equation} \label{CIC_gain}
G = (RM)^N
\end{equation}

Når et filter som dette implementeres i Python, skal man være opmærksom på, hvorledes dette gain ikke resulterer i at de typer der anvendes til at holde på samples ikke overstiges i størrelse. Der anvendes til dette unsigned integers som har en bit størrelse på 64. Derfor må output bit størrelsen ikke overstige dette, uden at overloade. Bit størrelsen på outputtet af filteret kan ud fra ligning \ref{CIC_gain}defineres som beskrevet i ligning \ref{CIC_gain_bit}. En illustration af konceptet med bit growth kan ses af figur \ref{fig:cic_growth_bits}.


\begin{equation} \label{CIC_gain_bit}
B_{out} = (N * log_2 * R * M + B_{in})
\end{equation}


\begin{figure}[H]
	\centering{}
	\includegraphics[width = 250 pt]{img/4_Studycases/bit_growth.pdf}
	\caption{CIC filter gain effekt på output bits}
	\label{fig:cic_growth_bits}
\end{figure} 

\pagebreak
\section{Frekvens korrektion} \label{appendix::studycase::frekvenskorrektion}
Når der transmitteres med radio, kan man sjældent være sikker på at den interne clock der sidder i sender og modtager er fuldstændig ens. Disse kan opleve temperatur drift eller ageing, som det hedder når denne clock drifter over tid. For at sikre sig mod disse fænomener, anvendes der typisk en frekvens korrektions blok i modtager systemer. 

Til KMR systemet anvendes en RTL-SDR enhed, som modtager til at sample radio signalerne. For at prøve at estimere frekvensoffsettet af denne, anvendes en signalgenerator til generering af en carrier der kan transmitteres ved en kendt frekvens. Hvis denne carrier modtages, med RTL-SDR enheden, vil man kunne evaluere placeringen af denne carrierer og dermed evaluere frekvensoffset på sender vs. modtager. Et eksempel på sådan en undersøgelse er udført med RTL-SDR modtageren, sammen med en LimeSDR bestående af transceiver chippen: LMS7002M \cite{lms7002}. Med denne LimeSDR transmitteres en carrier ved 866.6 MHz. Denne carrier vil herefter samples, ved brug af RTL-SDR enheden, og placeringen af carrieren evalueres. Dette ses af figur \ref{fig:freq_corr}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 150 pt]{img/4_Studycases/freq_corr.png}
	\caption{Frekvens offset estimering med RTL-SDR}
	\label{fig:freq_corr}
\end{figure} 

Det ses at frekvensoffsetet med denne metode estimeres til 563 Hz. Hvis dette sammenlignes med carrierfrekvensen på 866.6 Mhz, findes der at offset'et svarer til ca. 0.65 ppm (parts per million). Dette ses af ligning \ref{frekvensoffetppm}.

\begin{equation} \label{frekvensoffetppm}
f_{offset} = \frac{\Delta f}{f} = \frac{563 Hz}{868600000 Hz} = 0.648 * 10^{-6} = 0.648ppm
\end{equation}

\pagebreak

\section{FSK} \label{appendix::studycase::fsk}
For at kunne forstå hvordan moduleringsalgoritmen FSK fungerer, er det først nødvendigt at forstå hvad moduleringsprocessen har til formål. Når en datasekvens skal transmitteres, er det nødvendigt at kunne sende denne sekvens ved hjælp af, for Kamstrups tilfælde, radiobølger. Disse radiobølger udbredder sig som sinusbølger i luften, hvorfor det er nødvendigt at kunne repræsentere sin datasekvens ved hjælp af disse sinusbølger. 

Der findes forskellige metoder til at fastlægge data på sådanne radiobølger, men fælles for dem er, at de alle findes som kombinationer af de følgende 3 typer af modulation: ASK, FSK og PSK. \newline
ASK, eller amplitude shift keying, er en modulationstype, hvor amplituden på den transmitterede bølge, ændres i takt med datasekvensen der ønskes transmitteret. FSK, eller freqeuncy shift keying, er en modulationstype, hvor frekvensen på den transmitterede bølge ændres, i takt med datasekvensen der ønskes transmitteret. PSK, eller phase shift keying, er en modulationstype, hvor fasen på den transmitterede bølge ændres, i takt med datasekvensen der ønskes transmitteret. 

En illustration af disse 3 modulationstyper \cite{modulation-types} kan ses af figur \ref{fig:mod_types}

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 300 pt]{img/4_Studycases/mod_types.png}
	\caption{Modulations typer: ASK, FSK og PSK}
	\label{fig:mod_types}
\end{figure} 

I forbindelse med tidligere anvendte protokoller hos Kamstrup, anvendes standard FSK som modulationstype. For at udtrykke hvorledes FSK modulationstypen implementeres ses ligning \ref{fsk_1} for symbol 1 og ligning \ref{fsk_0} for symbol 0. 

\begin{equation} \label{fsk_1}
s(t) = \sqrt(2E_b / T_b) * cos(2 \pi * f_1 * t + \theta(0))
\end{equation}

\begin{equation} \label{fsk_0}
s(t) = \sqrt(2E_b / T_b) * cos(2 \pi * f_2 * t + \theta(0))
\end{equation}

Det ses at frekvensen f1 og f2, er det eneste der varierer mellem de forskellige symboler. Derudover er det værd at nævne at fasen mellem de 2 signaler for standard FSK vil være ens. 

\pagebreak

\subsection{Demodulering}
For at kunne implementere en demoduleringsalgoritme til denne modulationtype for KMR systemet, er det nødvendigt at vide hvorledes denne fungerer \cite{modulation-types}. En mulighed for demodulering af FSK signaler er, asynkront at lade det modtagne signal, gennem to forskellige båndpasfiltre, der hver sættes til en cuttofffrekvens passene til f1 og f2 fra ligning \ref{fsk_1} og \ref{fsk_0}. Outputtet af dette filter vil nu svare til et ASK signal, idet det udelukkende vil være signal at finde når denne frekvens anvendes, og der dermed transmitteres data. Derfor vil der kunne sættes en envelope detektor i serie med, som vil determinere hvornår der er signal. Envelope signalet vil derefter kunne sendes gennem et logisk kredsløb, der tjekker hvorvidt envelopen går højt eller lavt indenfor en given bit periode. Et sådant setup kan ses af figur \ref{fig:fsk_demod}

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 300 pt]{img/4_Studycases/fsk_demod.png}
	\caption{Demoduleringskredsløb til FSK}
	\label{fig:fsk_demod}
\end{figure} 

Denne teknik vil visse sig nyttig for udførelse af kravene om demodulering ved FSK. 

\section{GMSK} \label{appendix::studycase::gmsk}
Til den kommende protokol til Kamstrups systemer, vil det være GMSK der anvendes som modulationstype. Som nævnt i \ref{appendix::studycase::fsk}, findes 3 typer af standard moduleringer, nemlig FSK, ASK og PSK. GMSK er en speciel type af FSK, hvor forskellen mellem f1 og f2 er sat til det absolutte minimum, der stadig tillader ortogonal detektion af signalet. Ortogonal detektion af signalet betyder blot, at der ved GMSK (dermed også MSK) er nøjagtig 90 graders faseforskel mellem de to signaler der repræsenterer henholdsvis 0 og 1. Dette giver nogle specielle fordele med henblik på detektionen af data fra signalet. Dette beskrives mere detaljeret senere i dette afsnit. Viden omkring GMSK og analyse af dette bunder i viden indhentet fra \cite{com-systems}, \cite{sync-technique}, \cite{GMSK-article} samt \cite{GMSK-nutshell}.
\pagebreak 

\subsection{MSK - Minimum Shift Keying}
For at kunne beskrive MSK signaler, skal der først rekapituleres, hvorledes der repræsenteres FSK signaler med kontinuer fase. Dette blev gjort ved:

\begin{equation} \label{fsk_1_repeated}
s(t) = \sqrt(2E_b / T_b) * cos(2 \pi * f_1 * t + \theta(0))
\end{equation}

\begin{equation} \label{fsk_0_repeated}
s(t) = \sqrt(2E_b / T_b) * cos(2 \pi * f_2 * t + \theta(0))
\end{equation}

Af ligning \ref{fsk_1_repeated}  og \ref{fsk_0_repeated}, ses der at Eb er signal energien pr bit, mens Tb er er bit perioden. Vigtigt er det også at notere sig, at fasen af signalet summerer alle fasedrej af signalet op til tidspunktet t = 0. 

Disse to ligninger kan omskrives således vi, i stedet for at repræsentere signalet ved de to frekvenser for symbol 0 og 1, kan repræsentere signalet som en kontinuer faseændring til tiden t. Denne repræsentation er givet ved ligning \ref{cpfsk}.

\begin{equation} \label{cpfsk}
s(t) = \sqrt(2E_b / T_b) * cos(2 \pi * f_c * t + \theta(t))
\end{equation}

Der ser her at fasen er en kontinuer funktion af tiden. Det vil sige at fasen af CPFSK (Continous phase frequency shift keying) signalet drejes positivt eller negativt, afhængig af symbol 0 eller 1 inden for bit perioden Tb. Denne faseændring kan beskrives ved ligning \ref{phase_change}

\begin{equation} \label{phase_change}
\theta(t) = \theta(0) \pm \frac{\pi h}{T_b} * t
\end{equation}

Her beskriver plus tegnet et symbol 1, mens minus tegnet beskriver symbol 0. h er i denne ligning et forhold, der kaldes modulation index'et. Det vil vise sig at såfremt dette holdes på 0.5 vil forskellen mellem f1 og f2 netop være det mindst mulige der sikrer at signalerne stadig er ortogonale. 

Ud fra ligning \ref{cpfsk} og \ref{phase_change}, kan der siges at carrier frekvensen plus det potentielle fasedrej for et givent symbol, vil resultere i enten f1 eller f2 alt afhængig af det givne symbol. Denne sammenhæng beskrives i ligning \ref{f1_carrier} og \ref{f2_carrier}

\begin{equation} \label{f1_carrier}
fc + \frac{h}{2T_b} = f_1
\end{equation}

\begin{equation} \label{f2_carrier}
fc - \frac{h}{2T_b} = f_2
\end{equation}

Disse ligninger kan nu løses for henholdsvis modulation index h, og carrier frekvensen fc. Dette giver os ligning \ref{carrier} og \ref{mod_index}

\begin{equation} \label{carrier}
fc = \frac{1}{2} * (f_1 + f_2)
\end{equation}

\begin{equation} \label{mod_index}
h = T_b(f_1-f_2)
\end{equation}

Der er nu defineret henholdsvis carrierfrekvens og modulationsindexet for et FSK signal med kontinuer fase. Dette vil lede os hen i mod definitionen af MSK signaler, når der ses på den sammenhæng der er mellem modulationsindex og ortogonalitet i signalet.

Fra ligning \ref{phase_change} vides det at fasen af signalet til tiden Tb, ændrer sig som beskrevet i ligning \ref{phase_change_tb}. Der fratrækkes her den summerede fase op til tiden t = 0.

\begin{equation} \label{phase_change_tb}
\theta(T_b) - \theta(0) = \begin{cases}
    \pi h, & \text{for symbol 1}.\\
    -\pi h, & \text{for symbol 0}.
  \end{cases}
\end{equation}

Denne udvikling af fasen, som funktion af tiden, vil kunne illustreres med det der betegnes som et "Phase tree". Dette viser faseudviklingen ved forskellige perioder af Tb og ved forskellige symbol kombinationer. Dette "Phase tree" kan ses af figur \ref{fig:phase_tree}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 300 pt]{img/4_Studycases/phase_tree.pdf}
	\caption{"Phase tree"}
	\label{fig:phase_tree}
\end{figure} 

Der vides altså at til tiden t = Tb, vil fasen have drejet pi * h positivt eller negativt afhængig af symbolet. Hvad der nu kan udnyttes i forbindelse med MSK er, at hvis signalet drejes 2 pi, vil signalet være identisk med sig selv uden fasedrejet. Hvis dette udnyttes ved at sætte modulations index'et til 0.5 vil det betyde at fasen, efter 2 perioder, maksimalt kan have drejet pi radianer. Hvis symbolsekvensen herefter fortsætter med at lade fasen dreje positivt med 0.5 pi pr periode, vil der i stedet for at skabe 1 nyt punkt til detektion, som det ses af fase træet på figur \ref{fig:phase_tree}, kunne udnyttes et allerede kendt punkt i -pi halve. Dette gør at uanset hvordan symbolsekvensen udvikler sig, vil detektionspunktet kun kunne antage en lille mængde kendte punkter. Dette fænomen kan ses af figur \ref{fig:phase_trellis}. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 300 pt]{img/4_Studycases/phase_trellis.pdf}
	\caption{"Phase trellis"}
	\label{fig:phase_trellis}
\end{figure} 

Dette fænomen gælder dog kun såfremt modulations index'et holdes på 0.5. Tages dette og indsættes i ligning \ref{mod_index} og løses ligningen for forskellen mellem f1 og f2, ses der at denne skal være lig med den halve bitrate. Den halve bitrate vil altså være den mindst mulige forskel mellem f1 og f2, såfremt ortogonal detektion skal være mulig. Dette er grunden til af FSK signaler med kontinuer fase og et modulation index på 0.5 kaldes for MSK eller Minimum Shift Keying. 
\pagebreak 

\subsection{Gaussisk filter til (G)MSK} \label{gaussian_filter_heading}
Som nævnt tidligere, har MSK fordele i forhold til ortogonal fase detektion, som performer godt i forhold til andre modulationstyper. Derudover har MSK også kontinuer fase, som der lige er set, hvilket gør at problemer med ikke-lineær forstærkning i modtagere, ikke er aktuelle for MSK. Der er altså mange fordele med MSK. En af de problemer der dog er med MSK, er at denne type modulation breder sig mere end ønsket i frekvensspektret. 

Dette kan forklares med fourier rækker, der beskriver den firkantede puls der vil laves, som følge af den symbolsekvens der ønskes transmitteret. Der vides at der for at kunne definere en firkantet puls, skal denne bestå af summen af en uendeligt mange sinus frekvenser. Disse vil brede sig i frekvensdomænet og dermed lade MSK modulationen fremstå forholdsvist bredt. Dette vil kunne løses ved af forme symbolsekvensen ved baseband, med et filter der følger 2 ting:

\begin{itemize}
	\item Frekvensrespons med smal båndbredde og en skarp cutoff karakteristik
	\item Impulsrepsons med lavt overshoot
\end{itemize}

Grunden til frekvensresponsen skal have en smal båndbredde, er netop for at opnå en mindre udbredning af signalet i frekvensdomænet. Impulsreponsen med lavt overshoot følger samme tankegang med en lav udbredning. Herudover må filteret ikke ødelægge de gode aspekter der findes for MSK, i forhold til at kunne detektere CPFSK signaler ud fra fasen. Et filter der opfylder dette vil være et filter, hvis impulsrespons følger en gaussisk funktion. Et sådan filter vil være givet ved ligning \ref{gaussian}.

\begin{equation} \label{gaussian}
h(t) = \frac{k_1 B}{\sqrt(\pi)} * e^{-k_1^2 B^2 t^2}
\end{equation}

hvor B er givet ved båndbredden for den halve energi, mens k1 er givet ved: 

\begin{equation} \label{k1}
k_1 = \frac{\pi}{\sqrt(2 *ln(2))}
\end{equation}

Et plot af dette filter kan ses af figur \ref{fig:gaussian}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 300 pt]{img/4_Studycases/gaussian.png}
	\caption{Impuls respons af gaussisk filter}
	\label{fig:gaussian}
\end{figure} 

Ved at lade symbolsekvensen, der skal moduleres, blive formet af dette filter inden moduleringen, vil der opnås en smallere udbredning i frekvensdomænet, hvilket vil tillade plads til flere kanaler. Det ses, at man ved at lade BT blive mindre kan opnå en hårdere filtrering af signalet, hvilket vil resultere i en mindre udbredelse i frekvensdomænet. Grunden til man dog ikke lader BT blive utrolig lille er, at man derved også "filtrerer" i signalet selv. Der findes altså et tradeoff i mellem filtrering af signalet, i forhold til udbredning i frekvensdomænet. En standard som GSM anvender BT på 0.3 hvilket er en ret hård filtrering \cite{GSM-GMSK}.

Et eksempel på formning/shaping med et gaussisk filter i forhold til normal MSK, kan ses af figur \ref{fig:msk_gmsk}. Det ses at dæmpningen i frekvensdomænet er højere ved et givent punkt, for en højere værdi af BT.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 200 pt]{img/4_Studycases/msk_gmsk.png}
	\caption{MSK respons vs GMSK respons }
	\label{fig:msk_gmsk}
\end{figure} 

\subsection{Modulering} \label{modelering}
For at kunne demodulere GMSK signaler, er det nødvendigt at kende til hvorledes, et GMSK signal moduleres. Dette er nødvendigt idet, det langt hen ad vejen, er de inverse processer der udføres i demoduleringen i forhold moduleringen.

Moduleringen af GMSK foregår ved at lade de bits der ønskes transmitteret om til symboler, ved at lave en NRZ, Non Return to Zero, konvertering af dem. Herefter summeres symbolerne op, da det er denne summering der ønskes for den senere fasemodulering. Der vides jævnfør MSK afsnittet, at fasen lineært summeres op over en symbol periode. Efter summeringen påføres et gaussisk filter, ligesom det der netop er diskuteret i \ref{gaussian_filter_heading}. Efter dette frekvensmoduleres signalet med henholdsvis sinus bølger og cosinus bølger for indfase og quadrature fase komponenterne, hvor fasen samtidig drejes med 90 grader eller pi / 2 over hver symbolperiode. Til sidst moduleres de to komponenterne op på en bærebølge. En figur af denne moduleringsproces kan ses af figur \ref{fig:gmsk_mod}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/gmsk_mod.png}
	\caption{Blok diagram af GMSK modulator}
	\label{fig:gmsk_mod}
\end{figure} 

Et eksempel på et signal, der moduleres af denne type GMSK modulator, kan ses på figur \ref{fig:gmsk_mod_ex}. Det ses at input data-sekvensen på første billede er symbol konverteret til NRZ data. Herefter shapes symbolerne således disse præcis drejer pi / 2 eller 90 grader indenfor hver symbol periode. Fasen drejer positivt eller negativt alt efter hvilket symbol der er tale om (-1 eller 1). Herefter genereres det gaussiske filter, hvis impulsrepsons er vist på billede 3. Dette bruges til at shape fasen således denne får bedre spektral effektivitet. Til sidst vises hvorledes hver symbolperiode shapes med en cosinus halvbølge for indfase komponenten og en sinus halvbølge for quadrature fase komponenten. Disse to komponenter vises af billede 5 og 6 og er dem der til sidst vil moduleres op på en bærefølge i forbindelse med transmission. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 250 pt]{img/4_Studycases/gmsk_mod.pdf}
	\caption{Eksempel på signal moduleret med GMSK modulator}
	\label{fig:gmsk_mod_ex}
\end{figure} 

\pagebreak
\subsection{Demodulering}
Med den tidligere matematik vist i beskrivelsen af MSK signaler vides der at fasen for et MSK signal er kontinuer. Dette vil sige at fasen drejer lineært med 90 grader positivt eller negativt inden for en symbolperiode. Dette er en af de helt store fordele ved at bruge MSK som modulering idet det tillader ikke lineære forstærkere på modtageren. For at opnå denne lineære fase overgang mellem symboler er det nødvendigt, som der ses af afsnit \ref{modelering}, at shape symbolerne med henholdsvis cosinus og sinus bølger. Dette er hvad der eksempelvis adskiller MSK type modellering fra den ellers også anvendte OQPSK - Offset Quadrature Phase Shift Keying. Dette kan ses af figur \ref{fig:oqpsk_msk}. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 150 pt]{img/4_Studycases/oqpsk_msk.png}
	\caption{MSK modulering vs. OQPSK modulering}
	\label{fig:oqpsk_msk}
\end{figure} 

\subsubsection{Matched Filter} \label{matched_filter_heading}

Denne omtalte shaping af symbolerne er vigtig i forhold til den demodulerings proces der findes for MSK type modelleringer. Det første step i demoduleringsprocessen er at finde ud af hvor i det modtagne signal symbolerne ligger. Dette gøres traditionelt ved brug af et matched filter. Et matched filter fungerer ved at korrelere sit input signal med et kendt template, som vil matche det der ledes efter i signalet. En beskrivelse af template generering til MSK type demodulering kommer senere i dette afsnit. 

For at kunne lave et matched filter, ses der på hvorledes et normalt FIR filter fungerer. Et FIR filter har forskriften som ses i ligning \ref{fir_filter}

\begin{equation} \label{fir_filter}
y(n) = b_0 * x(n) + b_1 * x(n-1) + b_2 * x(n-2) + ... + b_M * x(n - M)
\end{equation}

Dette kan omskrives til \ref{fir_filter_sum}

\begin{equation} \label{fir_filter_sum}
y(n) = \sum_{m = 0}^{M} b_m * x(n - m)
\end{equation}

Hvis man i ligning \ref{fir_filter_sum} lader længden på FIR filteret M være uendelig stor, samt omskriver FIR koefficienter til et foldnings template, h har man ligning \ref{fir_filter_conv} som netop er forskriften for en matematisk foldning.

\begin{equation} \label{fir_filter_conv}
y(n) = \sum_{m = -\infty}^{\infty} h(m) * x(n - m)
\end{equation}

Der kan altså konkluderes at et normalt FIR filter faktisk laver en foldning når et signal løbes gennem filteret. Det der ønskes med det matched filter, er at lave en korrelering mellem template og input signalet. For at kunne gøre dette ses på sammenhængen mellem en matematisk foldning og en krydskorrelation. 

\begin{equation} \label{cross_corr}
y(n) = \sum_{m = -\infty}^{\infty} h(m) * x(n + m)
\end{equation}

Af ligning \ref{cross_corr} og \ref{fir_filter_conv} ses henholdsvis foldning og krydskorrelations matematiske forskrifter. Der ses at den eneste forskel er hvilken vej signalet løber igennem de matematiske operationer - nemlig det minustegn der findes for foldningen bliver til et plus tegn for kryds korreleringen. Her kan det dog udnyttes at templatet der leder efter, i MSK demodulering, er symmetrisk. Den lineære faseovergang mellem symbol perioder for MSK er opnået ved at shape hver symbolperiode med halve sinus bølger. Disse danner det template der ønskes korreleret efter i det matched filter der anvendes. Idet disse sinus halvbølger er symmetriske, kan der blot anvendes et normalt FIR filter til at lave det ønskede matched filter. FIR filterets impulsrespons skal dermed blot have form som den shaping der ledes efter for hver symbol periode. 

FIR filterets impulsrespons kan variere alt efter hvilken type af MSK modulering der anvendes. For normal MSK vil impulsrepsonsen blot være givet ved en normal sinusbølge, som følger formen beskrevet i ligning \ref{1REC_matched_filter}. Denne type filter benævnes "1REC". En anden kendt type af template til matched filter for MSK signaler er "2REC". Disse har formen som beskrevet i ligning \ref{1REC_matched_filter} og \ref{2REC_matched_filter}.

\begin{equation} \label{1REC_matched_filter}
h(t) = \begin{cases}
    \frac{sin(\pi t)}{2T}, & 0 \leq t \leq 2T\\
    0 & \text{elsewhvere}.
\end{cases}\end{equation}

\begin{equation} \label{2REC_matched_filter}
h(t) = \begin{cases}
    \frac{1}{2 \sqrt(2)}(1 + \sqrt(2) * sin(\frac{\pi}{2T}(t - \frac{T}{2}))) & 0 \leq t \leq 3T\\
    0 & \text{elsewhere}.
\end{cases}\end{equation}

Et plot af disse to typer af templates til det matched filter kan ses af figur \ref{fig:1rec_2rec}. Det ses at "2REC" pulsen breder sig mere, hvorfor denne ofte anvendes til GMSK. Dette skyldes da den yderligere shaping der findes for GMSK, gør at symbolsekvens bliver mere udglattet og derfor også breder sig mere. Det giver dermed et bedre "match" at anvende en bredere puls til GMSK matched filtrering.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 250 pt]{img/4_Studycases/matched_filter.png}
	\caption{1REC pulse vs 2REC pulse til matched filtrering}
	\label{fig:1rec_2rec}
\end{figure} 

Efter input signalet er kørt igennem det genererede match filter som beskrevet i \ref{matched_filter_heading}, vil der være opnået nogle peaks i korreleringen der kan detekteres. Der vides at fasen akkumulerer inden for en symbolperiode, og at en symbolperiode er defineret af den oversamplingsrate der findes for kommunikationslinket. Oversamplingsraten er defineret ud fra den samplefrekvens og den datarate der findes for den givne kanal. Disse delt med hinanden giver antallet af samples der findes inden for én symbolperiode. Der ønskes derfor nu at sample det filtrerede signal ved hver symbolperiode, for at kunne se på hvorledes fasen har ændret sig frem til hvert at disse samlingspunkter. 

Dette gøres for både signalet i indfase og i quadrature fase, altså drejet 90 grader. Dette gøres for at hente information for henholdsvis I og Q delen af signalet, hvor der i transmitteren lægges information på begge dele. Der vil på alle lige pladser af Tb (symbolperioden) være information embedded i indfase komponenten mens der på alle ulige pladser af Tb vil være information embedded i quadrature fase komponenten. For at lade den demodulerede data outputtes som en bitstrøm, ses der altså på fasedrejet på både I og Q og der defineres et array, hvor der skiftevis indsættes data fra I og Q komponenten. 

Det sidste der mangler i demoduleringsprocessen vil være den inverse differentielle enkodning. Denne er nødvendig på grund af den differentielle enkodning der er embedded i de anvendte transmittere. Der kan læses mere om differentiel kodning og den tilhørende inverse i \ref{diff_encoding}.

I forbindelse med moduleringen af GMSK signaler vides der nu at et gaussisk filter er nødvendigt for at shape symbolsekvensen således denne bliver mere spektral effektiv end tilfældet er med normal MSK. Ligeledes vides der at der i demoduleringsprocessen indgår et matched filter for at detektere symboler. Det er nødvendigt at være opmærksom på at der ved brug af filtre optræder et filter delay. Signalet vil med andre ord blive forsinket fordi det skal sendes igennem forskellige typer af filtre. 

Ser man på de to forskellige typer af templates, til det matched filter, der anvendes i demoduleringsprocessen, som ses af figur \ref{fig:1rec_2rec}, kan der ses hvorledes deres impulsrepsons spænder over forskellige længder af samples. Dette tydeliggøres ved at se figur \ref{fig:1rec_2rec_delay}, hvor de to filtres filter delay er plottet ind. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 250 pt]{img/4_Studycases/matched_filter_delay.png}
	\caption{1REC pulse vs 2REC puls filter delay}
	\label{fig:1rec_2rec_delay}
\end{figure} 

Disse delays kan der tages højde for når symbolperioderne Tb "samples". I stedet for at starte ved signalet begyndelse, skal der introduceres et offset i starten svarende til disse filter delays. Gøres dette ikke, vil der være et synkroniseringsproblem, som kan skabe problemer i forhold til ISI: Inter Symbol Inteference. Dette kan der læses mere om i \ref{ISI}.

\pagebreak
\section{ISI - Inter Symbol Interferens} \label{appendix::studycase::isi}
Inter symbol inteference, er et problem der opstår når de enkelte symboler i en given transmission, "flyder ud" i hinanden og dermed interfererer. Dette problem opstår typisk når den timing der ligger i hvornår symbolerne optræder, ikke er korrekt. Inter symbol inteference kan give problemer i forhold til at modtage de korrekte symboler. 

En typisk måde hvorpå ISI optræder i forbindelse med GMSK er i forhold til den gaussiske filtrering der ligger inden modulationen. Denne filtrering kan, jævnfør \ref{appendix::studycase::gmsk}, være mere eller mindre hård. En hård filtrering vil resultere i bedre spektrale egenskaber, men ligeledes vil filtreringen resulterer i, at noget symbol information filtreres væk. Dette kan gøre at det fasedrej der ellers skal ligge på pi / 2 for hver symbolperiode for GMSK, ikke når helt op på de 90 grader. Dette leder til en mistiming af symboler som kan lede til ISI. Derfor er den gaussiske filtrering underlagt, et tradeoff i forhold til ISI.  

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/aci.png}
	\caption{ISI illustreret}
	\label{fig:ISI}
\end{figure} 

\pagebreak
\section{ACI - Adjecent Channel Interferens} \label{appendix::studycase::aci}
I forhold til den definerede kravspecifikation for KMR systemet skal der allokeres op til 8 kanaler, hvor alle er lokaliseret i 868 MHz (ISM båndet). I forbindelse med multikanalssystemer med høje datarater kan ACI eller Adjecent Channel Interference blive et problem \cite{ACI}. Derfor vil der i denne study case undersøges hvad ACI præcist er og hvorledes der i design og implementeringen kan tages højde for dette. 

Når der transmitteres data, er det naturligt at binære data repræsenteres som en firkant puls i tidsdomænet. Dette sker da der i tilfældig rækkefølge sendes 1'er og 0'er. En firkant puls i tidsdomænet vil i frekvensspektret optræde som en sinc bølge. Lad os antage at den firkantede puls i tidsdomænet er afgrænset til perioden t. Den ækvivalente sinc bølge i frekvensspektret vil her have sin primære energi i samme periode t, men noget enerig vil flyde uden for -t til t. Dette er ikke noget problem, såfremt frekvensspektret ikke er optaget i det område, hvor sinc bølgen vil flyde ud. Dette kan dog være tilfældet for multikanalssystemer idet, kanalen kan flyde over i spektret for en anden kanal og dermed skabe ISI. 

Problemet opstår ofte idet der på en kanal kræves en høj datarate. Jo højere datarate en kanal har, jo mindre vil pulsen være i tidsdomænet. Den nødvendige båndbredde for en sikker transmission, findes som 1 / periode for pulsen i tidsdomænet. Derfor vil den nødvendige båndbredde stige idet dataraten hæves. Dette kan lede til ACI. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/ISI.pdf}
	\caption{ACI illustreret ved varierende båndbredde}
	\label{fig:ACI}
\end{figure} 

\pagebreak
\section{Differentiel enkodning} \label{appendix::studycase::diffencoding}
Ud fra kendskab til Kamstrups modellering af GMSK signaler, til de målere der skal anvende den nye IOT4M protokol, er det kendt at der her anvendes differentiel encoding. Differentiel encoding bruges for at sikre sig imod at bits der modtages, er skiftet i polaritet \cite{diff-enc}. Dette vil være ligegyldigt ved brug af differentiel encoding hvorfor man vil opnå en bedre performance ved brug af denne teknik. 

Differentiel encoding sker ved at lade en rå bitstrøm blive defineret ud fra skift i data, frem for den rå datastrøm der ellers ville transmitteres. Såfremt de rå bits er skiftende i sekvensen, vil den differentielt kodede sekvens være konstant høj. Først når den rå bitstrøm holdes på samme niveau over to symbolperioder, vil den differentielt kodede sekvens gå lav. På den måde er det niveau skift i datasekvensen der definerer den transmitterede sekvens. 

Af figur \ref{diff_encoding} ses en illustration af denne differentielle encoding. I og med denne er embedded i de transmitterede GMSK signaler, vil en invers proces af denne være nødvendig for at kunne lave en modtager algoritme. I den inverse proces vil man altså blot lade sin outputbitstrøm skifte når den modtagne differentielt kodede bitstrøm holdes konstant og på samme måde holdes sin output bitstrøm konstant når den modtagne differentielt kodede bitstrøm er skiftende. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/diff_enc.pdf}
	\caption{Illustrering af differentiel encoding}
	\label{fig:diff_enc}
\end{figure} 

\pagebreak
\section{Pakkedetektion} \label{appendix::studycase::pakke_detektion}
Når der transmitteres pakker på en given kanal i systemet, skal det være muligt at kunne lokalisere præcis hvor denne pakke findes i signalet. Måden dette gøres på er ved at synkronisere sender og modtager, således det er kendt hvornår en transmission starter. Til denne proces er der to kendte redskaber.

\begin{itemize}
	\item Preamble 
	\item Syncword
\end{itemize}

En preamble er en sekvens af skiftende 1'ere og 0'ere som vil komme i en given længde. Denne sekvens kan man lede efter for at kunne detektere hvornår en pakke transmission starter. På samme måde findes Syncword. Dette er en sekvens som er kendt mellem modtager og sender. Senderen vil embedde syncword i datasekvensen, typisk som tegn på at headeren er slut og payload dataene er det næste der kommer i datasekvensen. Derfor bruger man typisk syncword til at synkronisere op i mod ved transmission og modtagelse. 

Måden Syncword vælges på, vil være i forhold til hvad der er bedst at korrelere efter. Når preamble og syncword skal lokaliseres i signalet, gøres det ved at definere et template indeholdende disse sekvenser. Herefter korrelerer man signalet med template, og finder de peaks hvor signalet matcher templatet. Ud fra kendskab til transmitteren om hvor disse sekvenser er placeret i signalet, kan de korrekte samples nu findes, hvorefter de eventuelt kan videresendes til yderligere processering. Netop af denne årsag er det også vigtigt at syncword specielt har en form der er god at korrelere efter - især i meget støjfyldte miljøer. Dette vil typisk blive evalueret inden valg af syncword. Disse evalueringer spænder uden for afgrænsningen af dette projekt. Syncword, for dette projekt og KMR systemet, er fundet af Kamstrup.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 225 pt]{img/4_Studycases/korrelation.png}
	\caption{Korrelering med firkant puls}
	\label{fig:correlation}
\end{figure} 

Af figur \ref{fig:correlation} ses det hvordan et signal, der er fuldstændig embedded i støj, nogenlunde kan lokaliseres ved at korrelerer med en firkant puls. Denne korrelering vil kun blive bedre ved at evaluere den bedst performende sekvens til syncword. 

\pagebreak
\section{Signalstyrke beregning} \label{appendix::studycase::signalstyrke}
Som følge af den kravspecifikation, der er defineret for KMR systemet, er det defineret at der skal udregnes og visualiseres signalstyrke for de pakker der modtages. Derfor er det nødvendigt at bestemme hvorledes RF poweren bestemmes ud fra IQ signaler \cite{iq-power}. 

For at rekapitulere, defineres I og Q som henholdsvis indfase og qudrature fase komponenter. Dette vil sige at de to er 90 grader forskudt. Illustreres dette i et phasor diagram, vil I komponenten ligge i 0, mens Q komponenten vil ligge i pi / 2. Vektoren mellem disse to komponenter vil udgøre det komplette signal. Det er derfor den absolut værdien af denne vektor der ønskes at finde, således at RF poweren kan findes. Dette er illustreret på figur \ref{fig:IQ_power}. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 250 pt]{img/4_Studycases/IQ_power.pdf}
	\caption{Fase diagram der viser sammenhængen mellem I og Q komponenter}
	\label{fig:IQ_power}
\end{figure} 

Ved hjælp af pythagoræiske læresætning kan der nu bestemmes den RF signalspænding der er givet for signalet ved at finde længden på den viste vektor. Dette gøres ved ligning \ref{v_peak}.

\begin{equation} \label{v_peak}
V_{peak} = \sqrt{(I^2 + Q^2)}
\end{equation}

Der vides dog at I og Q vektorene vist på figur \ref{fig:IQ_power}, er peak værdierne for de to komponenter. Ønskes der derimod at finde RMS (Root Mean Square) værdien, deles der med kvadratrod 2 som vist i ligning \ref{v_rms}.

\begin{equation} \label{v_rms}
V_{rms} = \frac{V_{peak}}{\sqrt{2}}
\end{equation}

Ønskes der nu at definere poweren/effekten, i stedet for spændingen, tages ohms lov i brug som definerer at spændingen kvadreret delt med modstand giver effekt. Der vides at modstanden i receiveren fra RTL-SDR enheden 50 ohm. Dette ses af ligning \ref{p_rms}.

\begin{equation} \label{p_rms}
P_{rms} = \frac{V_{rms}^2}{50}
\end{equation}

Dette udtryk kan herefter simplificeres til ligning \ref{p_rms_simp}.

\begin{equation} \label{p_rms_simp}
P_{rms} = \frac{I^2 + Q^2}{100}
\end{equation}

Ofte ønskes der at kunne definere effekten i dBm, altså dB i forhold til en milliwatt. Dette gøres ved log 10 til effekten og dele med 1 milliwatt som vist i ligning \ref{p_dbm}.

\begin{equation} \label{p_dbm}
P_{dBm} = 10 * log(\frac{P_{rms}}{1mW}) 
\end{equation}

\pagebreak
\section{Database} \label{appendix::studycase::database}
Ud fra de funktionelle og yderligere krav til KMR systemet, dannes der grundlag for at den processerede data konstrueres til et dataobjekt og derefter uploades til en database, som KMR systemet agerer som en ekstern aktør. \newline

Der er flere årsager til dette:

\begin{enumerate}
	\item Flere brugere af systemet: Såfremt der ikke var en database og dataene blev lagt lokalt på en computer, vil der ikke være mulighed for at andre brugere kan tilgå samme data.
	\item På baggrund af ovenstående punkt vil der dermed også være mulighed for, at flere kunne teste på de kommende Kamstrup målere parallelt af hinanden, ved brug af KMR systemet som test-værktøj.
\end{enumerate}

\subsection{Database type}
På baggrund af de nævnte krav, danner der sig nogle rammer for valget af databasen med henblik på ydeevne og data-objekt håndtering. Hermed skal der undersøges, hvilken type af database der vil kunne omslutte disse krav bedst muligt. 

Da gruppen ikke har stor erfaring med databaser, vil der som udgangspunkt blive kigget på databaserne som hyppigst bliver brugt i udviklingsprojekter. \newline
Herunder, i figur \ref{fig:db_engines_db_ranking}, ses en oversigt over nogle af de hyppigst implementerede databaser. Dataene for denne indeksering er beregnet ud fra interesseundersøgelser på Google Trends, omtaler af systemerne på det globale netværk, samt diskussioner på implementeringsforummer for databaser, samt omtale af databaserne i jobopslag og profiler på professionelle netværk \cite{db_engines_ranking_definition}. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 300 pt]{img/4_Studycases/db_ranking.png}
	\caption{Database rangering}
	\label{fig:db_engines_db_ranking}
\end{figure} 

Ud fra ovenstående figur, \ref{fig:db_engines_db_ranking}, er der to forskellige typer af databaser iblandt de i alt 4 rangerede databaser:
\begin{itemize}
	\item SQL
	\item NoSQL
\end{itemize}

Dermed er der dannet grundlag for en undersøgelse af ovenstående typer af databaser, således der kan vælges én passende ekstern Database aktør til KMR systemet, som passer til de stillede krav.

\subsubsection{SQL}
Type-databasen, SQL, er baseret på "Structured Query Language", hvilket ligger grundlag for SQL-forkortelsen \cite{sql_explained}. \newline
Det strukturerede sprog i database-typen anvender prædefinerede struktureringer indeni databasen. Det vil sige at strukturen for databasen og dens indhold skal være defineret på forhånd af selve implementeringen og eventuelle udvidelser af systemet. Dermed skal alle data følge samme struktur som givet på forhånd. Muligheden for at ændre i felter, således der kan tilføjes ekstra kolonner til rækker af data, er muligt. Det er dog på bekostning af at der skal plottes en værdi ind på alle eksisterende rækker af data, som kommer til at få tilføjet netop samme nye kolonne.

Af krav (8.2) af de Yderligere krav, i Specifikations-afsnittet i rapporten, defineres de data-felter som Databasen skal kunne indeholde:

\begin{itemize}
	\setlength\itemsep{0,1em}
	\item Meter ID
	\item Channel number
	\item Channel frequency
	\item Timestamp
	\item Signal strength
	\item Payload
\end{itemize}

Såfremt der skulle tilføjes et felt mere til data-objektet til KMR systemet, såsom en værdi der tilkendegiver installationsnummer på måleren, vil dette selvfølgelig også skulle afspejle sig i SQL databasen. Dermed ville det være en nødvendighed at oprette en ny kolonne i tabel  \ref{tab:sql_data_struktur}, således de nye konkurstruede data-objekter i KMR systemet kan uploades til databasen.

Grundet den strukturerede tilgang i SQL betyder det dog at alle andre række af data (data-objekter) er nødsaget til at skulle have en værdi i den nye kolonne. Denne værdi må gerne være 0 eller NULL, men det er en nødvendighed at gå ind i databasen og ændre dette. Dermed kan der være et større arbejde ift. vedligeholdelse af databasen, såfremt KMR systemet skal videreudvikles eller at pakke-strukturen ændrer sig på beslutning fra Kamstrup, undervejs eller efter projektet.

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{1cm}   p{2cm}	p{2cm}   p{2cm} p{1,5cm}   p{3,5cm} }
		\multicolumn{6}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries SQL struktur} \\
		%\tableHeaderStyle
		AEEA & Channel 5 & 868.49 MHz & 10:46:21 & -10 dBm & 5845bfea551ec076 \\
		AEEA & Channel 1 & 868.07 MHz & 10:44:58 & -8 dBm  & 24fa89BB8ACBA872 \\
	\end{tabu}
	\caption{SQL data struktur i rækker og kolonner}
	\label{tab:sql_data_struktur}
\end{table}

Denne tabel-strukturering der implementerer sig i SQL databaser er meget rigid. Den funktionerer godt i systemer til varer, økonomi og lignende, da der hurtigt og effektivt kan udtages bestemte data fra rækker grundet databasens opbygning og struktur. Såfremt man ønsker sådanne data-udtræk af SQL databaserne hurtigere end NoSQL. \cite{sql_explained}

\subsubsection{NoSQL}
Type-databasen, NoSQL, er i modsætning til SQL-databaser ikke struktureret. De lægger derimod op til en dynamisk opbygning af data i databasen. Dette skyldes at databasen ikke er tabel-baseret, men i stedet (oftest) er bygget op af dokumenter \cite{nosql_explained}. \newline
Et sådan dokument ses herunder i figur \ref{fig:no_sql_document_strukturering}. 

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 170 pt]{img/4_Studycases/nosql_structure.png}
	\caption{NoSQL dokument strukturering}
	\label{fig:no_sql_document_strukturering}
\end{figure} 

Med denne type af dynamisk strukturering, er der dermed plads til nemt at kunne tilføje flere felter og tilhørende værdier i data-objekter til databasen. Dette kan gøres helt uden at skulle ændre på den forhenværende struktur. Det vil dog også have et negativt bidrag til ydeevnen, såfremt man skulle finde værdier for en bestemt række felter - eksempelvis "Payload" værdien for alle dokumenter. Således er det en nødvendighed at skulle scanne alle dokumenter for denne værdi, hvilket ville tage længere tid i modsætning til en struktureret database, SQL, som blot kan returnere værdien for alle rækker, da denne ved at værdien findes for alle rækker. \cite{nosql_explained}

\subsubsection{SQL vs noSQL}
Begge typer af databaser har under sin vifte en bred række af databaser som kan implementeres med utallige forskellige udviklingssprog, herunder Python 3.7 som nævnt under krav (3.1) i Yderligere krav afsnittet i Specifikationsafsnittet i rapporten.

Med udgangspunkt i afsnittene af SQL og noSQL kan det konkluderes, at der er fordele og ulemper ved begge database-typer.
Såfremt der ønskes en database, hvor alt er nøje struktureret og der hurtigt kan hentes bestemte værdier i hvert data-objekt/række/dokument, bør man vælge SQL.
Da KMR systemet skal bruges som test-værktøj til en måler der endnu ikke er færdigudviklet ses det som en fordel at lave KMR systemet efter at være så adaptivt som muligt, såfremt at Kamstrup skulle ændre pakke-strukturen eller have andre behov med henblik på Databasen og dens struktur. På baggrund af ovenstående ses noSQL-databaserne som et udmærket valg af database type. 

\subsection{MongoDB}
Jævnfør krav (8.1), som omhandler håndtering af JSON data-objekter, og figur \ref{fig:db_engines_db_ranking} virker en MongoDB som en god database i og med den opfylder alle former for krav til databasen som KMR systemet skal interagere med og data-objekt strukturen. 

MongoDB lagrer data som JSON-opbyggede dokumenter, som også ses i figur \ref{fig:no_sql_document_strukturering}. Hermed får man fordelene fra NoSQL type-databaserne, hvori der frit kan ændres i strukturen fra dokument til dokument, uden at påvirke de resterende dokumenter i samme database \cite{mongodb_LDAP}. MongoDB er den hyppigst brugte NoSQL database og er desuden gratis og open-source. Dette ligger grundlag for en stor vidensdatabase i form af udviklerforummer og lignende. 

Opbygningen i en MongoDB database fungerer som sagt ikke på lige fod med den strukturerede tilgang i MySQL, hvor der ikke er plads til rettelser undervejs eller efter endt udvikling, såfremt der kommer flere krav til et system efterfølgende. I stedet er denne opbygget af Collections som danner rammen om Documents der indeholder selve dataene. Et document er opbygget af X antal Fields som kan være grupperinger, strings, integers mm. Dette er illustreret i figur \ref{fig:mongodb_database_collection_document_} herunder.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 220 pt]{img/4_Studycases/mongodb_database_collection_document.png}
	\caption{MongoDB database, Collection og Document strukturering}
	\label{fig:mongodb_database_collection_document_}
\end{figure}

\pagebreak

\subsection{Sikkerhed}

Der er en række af sikkerheds tiltag som kan implementeres på en MongoDB database, såfremt dette skulle ønskes. Disse tiltag er per default ikke sat som standard ved installation og opsætning af en MongoDB database. Dermed er det en nødvendighed selv at oprette og vedligeholde, såfremt at behovet skulle være for dette. \\

\subsubsection{Bemyndigelse}
MongoDB indeholder muligheden for at lave forskellige typer af brugere til udviklere, systemer eller andet. Hermed kan det sikres at kunder som benytter virksomhedens database eksempelvis, kun har ret til det data som er relevant for deres virksomhed, fremfor at have adgang til alle collections og documents i databasen. Dermed har virksomheden ikke adgang til andre virksomheders data, da deres bruger som tilgår databasen, er blevet tildelt en bestemt rolle.

Der er forskellige typer af roller. Den mest nødvendige er en admin-rolle, som har fuld adgang til alt og kan prædefinere roller ved oprettelse af nye brugere eller redigere i nuværende. Hermed administreres brugerne med adgang til databasen igennem denne administrator-rolle \cite{mongodb_roles}. \\

\subsubsection{Godkendelse}
Der er mulighed for at implementere et godkendelses-system til en eksisterende MongoDB database. 
Denne benytter sig af LDAP godkendelse, Lightweight Directory Access Protocol, som er baseret på TCP/IP kommunikation igennem netværket. Hver gang en bruger eller system vil tilgå databasen skal der sendes credentials med i anmodningen. Herefter vil MongoDB databasen sende forespørgslen videre til en LDAP server, som laver en forespørgsel/query i sit system om at finde de specifikke borgerrettigheder for de respektive credentials som er blevet sendt med til LDAP serveren. Når disse er fundet, returneres der til MongoDB databasen hvilke collections, documents og fields som brugeren eller systemet har adgang til \cite{mongodb_LDAP}. \\

\subsubsection{Transport kryptering}
En MongoDB instans supporterer TLS/SSL (Transport Layer Security/Secure Sockets Layer), således al MongoDB databasens indgående og udgående trafik kan krypteres. Dermed vil succesfulde sniffing af data ikke kunne demoduleres uden brug af krypterings-nøglen. Dette resulterer i at netværks trafik imellem MongoDB databasen og klienten (bruger eller system) udelukkende kan læses af klienten.

Denne kryptering fungerer grundet PEM filer, som ligger lokalt, og bruges til krypteringen og dekrypteringen af transmissioner af transporten imellem databasen og klienten. Disse kan både udstedes af certifikatorganisationer eller laves selv, såfremt det er et mindre system der skal laves. \cite{mongodb_encryption}

Yderligere er der mulighed for kryptering af selve dataene i MongoDB databasen, såfremt dette også skulle anses som en nødvendighed.\\

\subsubsection{Logging}
"Auditing" funktionaliteten i MongoDB er tilgængelig og brugbar i form af logging i databasen, hver gang der sker noget som er angivet i ens prædefinerede Audit Event og Filter. Dette kan eksempelvis være en godkendelsesproces eller anmodning om bemyndigelse for at tilgå visse collections eller documents i en database. \\

\subsubsection{Data-følsomhed}
Som resultat af GDPR loven (Databeskyttelsesforordningen) \cite{GDPR} der trådte i kraft og finder anvendelse fra d. 25. maj 2018, har MongoDB organisationen udviklet en "Governance" sektion til deres database instans, MongoDB, som kan tage hånd om denne. Denne er med til at sørge for at virksomheder forsat kan benytte sig af MongoDB som database, såfremt der skulle være personfølsomme oplysninger gemt i databasen. Denne funktionalitet kaldes "Document Validation" og går basalt set ud på at checke hvilke fields og documents som må høre indunder specifikke collections.\\

Ved brug af ovenstående beskrevet funktionalitet, sammen med rolle-funktionaliteten tidligere beskrevet, checkes der om en bestemt rolle har adgang til at tjekke et givent CPR-nummer eller lignende, såfremt KMR systemet i fremtiden skulle komme til at indeholde dette. Dermed er der mulighed for at inkorporere overensstemmelse i databasen med Databeskyttelsesforordningen/GDPR. \\

\subsection{Database tilgang}

For at kunne tilgå denne database fra systemets side er det nødvendigt at have en tilgang til databasen fra systemet i form af et interface. Jf. kravet til systemet om Python som udviklingssprog er der behov for at finde en måde et kunne tilgå en MongoDB database som opfylder dette krav.
Python moduldistributionen, PyMongo, er ifølge MongoDB organisationen den anbefalede måde at skabe broen imellem applikationer og MongoDB database API'en. Denne ville kunne bruges i KMR systemet til at kunne skrive og læse fra databasen indefra systemets grænser. \\

Da KMR systemet udvikles som et test-værktøj, til Kamstrups kommende målere, kan der dermed argumenteres for at systemet gerne skal være så løst koblet som muligt. Hermed vil der være mulighed for at kunne ændre og tilføje ny funktionalitet til systemet på bedst mulig vis. \\

Grundet ovenstående kan der derfor argumenteres for at KMR systemet bør indeholde en webservice, således at den eksterne Database aktør er nem at tilgå igennem eventuelle system-udvidelser til KMR systemet, eller andre systemer som også skal have adgang til samme database. \\

\pagebreak
\section{Webservice} \label{appendix::studycase::webservice}
På baggrund af afsnittet "Database tilgang" undersøges der, hvorvidt en webservice ville virke som bro fra KMR systemets kald til Databasen. På denne måde ville kald fra systemet altid skulle eksekveres på samme måde - altså en slags API (Application Programming Interface). Dette vil betyde, at eventuelle udbygninger af systemet nemt ville kunne tilbygge funktionaliteten til at kunne læse og skrive til databasen igennem denne webservice. Yderligere kan der argumenteres for at databasen i fremtiden skulle kunne bruges af andre systemer eller klienter. Således ville de også have mulighed for at kunne kommunikere lettere til Databasen - lige så vel som KMR systemet. \\

\subsection{Webservice type - RESTful}
Såfremt en webservice skal inkluderes i systemet, skal der undersøges hvorvidt der kan findes en passende webservice type.

Grundet kravet om JSON data-objekter, krav (8.1) i "Yderligere krav" i specifikationsafsnittet i rapporten, er der behov for en webservice type som er konstrueret til at håndtere JSON data som payloaden i dataoverførslen.
Med udgangspunkt i dette krav vil en RESTful webservice \cite{IBM_restfull_concept} fungere godt i KMR systemet som bro imellem resten af systemet og den eksterne aktør, Databasen. \cite{restfull_concept} \\

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 220 pt]{img/4_Studycases/restful_webservice.png}
	\caption{Forskellige enheder tilgår databasen igennem RESTful webservice}
	\label{fig:restful_webservice}
\end{figure}


Med udgangspunkt i krav (3.1) skal systemets databehandling laves i Python. Selve webservice delen og broen til databasen må derfor også skulle udvikles i dette udviklersprog da upload, download og pakning af flere data-objekter også hører under databehandling termen. \\

\subsection{Flask framework}
Jævnfør kravet om Python som udviklersprog er der dannet behov for at finde en passende webservice framework som kan benyttes til systemet.

Microframeworket, Flask \cite{FLASK}, er netop udviklet i Python og er dermed også til rådighed og benyttelse i selvsamme udviklersprog.
Flask frameworket benytter sig af en template engine ved navn Jinja2 \cite{JINJA} samt Werkzeug \cite{WERKZEUG}, der er et WSGI toolkit.

WSGI, eller Web Server Gateway Interface, er modulet som gør at Flask kan agere som webservice, da denne kan modtage forespørgsler og behandle disse. Hertil er det op til udvikleren at kunne administrere brugen af Flask frameworket, således det implementeres som et RESTful interface. Denne WSGI er normalt brugt til udvikling og testning. Ved et færdiglavet system som skal bruges i produktion anbefales der fra Werkzeug side at benytte sig af en WSGI på produktionsniveau således den kan håndtere betydeligt flere anmodninger.

Jinja, template engine, er den anden af byggestenene for frameworket Flask og kan bruges til at bygge HTML templates, som kan returneres til et device der tilgår et Flask endpoint. Herefter er det op til udvikleren af det respektive system at bestemme hvad der skal returneres. Dette kan være alt fra HTML hjemmesider til mindre svar som en integer eller string. \\

\subsection{Protokol HTTP}

Med udgangspunkt i læringsmålene fra IBM-artiklen om konceptet om RESTful webservice skal API delen af webservicen kortlægges.

Her er der forskellige muligheder. Den mest gængse af slagsen er HTTP metoder og anmodninger. Disse kendes fra brug af en browser til navigering på hjemmesider og lignende. Dog lægger man ikke mærke til selve kaldende. Hver gang en bruger benytter sig af en browser til at tilgå en hjemmeside, bliver der benyttet et HTTP GET kald til at anmode om indholdet på hjemmesiden. Denne request bliver behandlet af DNS servere, som først og fremmest finder vejen til den korrekte adresse/modtager igennem et IP-addresse look-up. \newline
Jævnfør krav (8.6) skal KMR systemet være på lokalt netværk. Derfor skal der ikke tages hånd om DNS-server, domæner og lignende. Dette betyder at IP-adresse look-up vil blive gennemført af routeren i det lokale netværk - hvilket øger performance og sikkerheden af dataene, såfremt det lokale netværks WiFi er polstret med sikkerhed som WPA2. 

Der er findes et utal af forskellige HTTP metoder med hver deres specifikke funktionalitet. Der er dog nogle af metoder, som er mere hyppigt anvendt end resten i henhold til udvikling af en RESTful webservice \cite{http_methods_restful}. Disse kan ses herunder i \ref{tab:http_metoder}. \\

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{2,5cm} p{3cm}  p{6cm} }
		\multicolumn{3}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries HTTP metoder til brug på RESTful webservice} \\
		\kravHeaderStyle
		Metode & CRUD operation & Forklaring \\
		
		HTTP GET & Read &  Anmodning om at læse data   \\
		HTTP POST & Create & Anmodning om at skrive data  \\
		HTTP DELETE & Delete & Anmodning om at slette data  \\
		HTTP PUT & Replace & Anmodning om at overskrive eksisterende data \\
		HTTP PATCH & Partial update &  Anmodning om at opdatere noget af eksisterende data \\
	\end{tabu}
	\caption{HTTP metoder til brug med RESTful webservice}
	\label{tab:http_metoder}
\end{table}

CRUD operationerne defineret i tabellen \ref{tab:http_metoder} er betegnelser der benyttes i en database kontekst.

Med henblik at skulle benytte disse HTTP metode kald på en webservice som på baggrund af disse kontakter en database, er det nødvendigt at kende til konteksten i hvordan kaldene skal benyttes, således at den rigtige kontakt bliver skabt til databasen. \newline
Herunder i tabel \ref{tab:http_metoder_mongodb} er der angivet hvad HTTP metoderne oftest associeres med ved kald af disse til webservicen, samt hvordan webservicen i så fald skal håndtere disse kald i forhold til databasen. \\


\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{2,5cm} p{4cm}  p{7cm} }
		\multicolumn{3}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries HTTP metoder til brug på RESTful webservice til MongoDB database} \\
		\kravHeaderStyle
		HTTP Metode & Collection & Document \\
		
		GET & Benyttes til at oprette et dokument i en collection. &  Benyttes til at hente et specifikt document ud, såfremt et ID følger med som parameter på HTTP kaldet.   \\
		POST & Kan benyttes til at oprette et dokument i en collection. & Frarådes at benytte kaldet på et document. Returnerer fejl.  \\
		DELETE & Kan benyttes til at slette en hel collection. Benyttes varsomt. & Benyttes til at slette et specifikt document ud, såfremt et ID følger med som parameter på HTTP kaldet.  \\
		PUT & Bruges ikke, medmindre alt i collection ønskes overskrevet & Benyttes til overskrivning af enkelt dokument \\
		PATCH & Benyttes generelt ikke, medmindre collection ønskes modificeret &  Benyttes til at opdatere et specifikt document, såfremt et ID følger med som parameter på HTTP kaldet. \\
	\end{tabu}
	\caption{HTTP metoder til brug med RESTful webservice}
	\label{tab:http_metoder_mongodb}
\end{table}

Hermed er der klargjort at HTTP metoderne er sublime at bruge til en RESTful webservice, såfremt disse bliver implementeret efter hensigten. \newline
HTTP metoderne skal kaldes på en adresse til webservicen, eksempelvis: \newline

HTTP GET http://website.org/collection/documents. \newline

Ovenstående HTTP metode og adresse eksempel ville typisk implementeres på webservicen således at den vil hente alle documents, i en respektiv collection, og returnere disse til enheden der lavede HTTP kaldet på webservicen.
Dette kaldes webservice endpoints og ovenstående danner grundlag for at KMR systemet skal have defineret og muligvis implementeret disse. \\

\pagebreak
\subsection{Endpoints}

World Wide Web Consortium's Web Service Description Working Group har defineret en specifikation ved navn WSDL 2.0, hvilket specificerer endpoint definitionen \cite{WSDL}. \newline
Helt basalt er et endpoint en URL-adresse som kan tilgås. Alt efter hvordan webservicen og endpointet er opsat, kan forskellige HTTP metoder på endpointet, have forskellige outputs. Dette kommer an på, hvordan webservicen og det specifikke endpoint er blevet implementeret.

Endpoints bliver oftest brugt i sammenhænge hvor et program skal kommunikere med et anden program i en given kontekst. Hertil bruges endpoints og eventuelle parametre som en slags API imellem disse programmer, således at alle typer af programmer kan udvikles til netop denne kommunikation. Igennem endpoints og et RESTful API sikres det dermed, at der på tværs af udviklingssprog, altid kan kommunikeres igennem denne webservice og endpoint. Dette skyldes at input og output forbliver ens - på tværs af platforme. 

\subsection{Blueprints}

Flask frameworket som kan benyttes til en webservice, kan som udgangspunkt kun bruges i main-kilde-koden i et Python script. 

Ovenstående er et problem i henhold til at der tidligere i rapporten har været fokus på at gøre KMR systemet så løst koblet som muligt, således at der nemt kan redigeres eller tilføjes nye funktionalitet i systemet. Dermed er det ikke hensigtsfuldt at Flask frameworket udelukkende kan bruges til at mindre applikationer ved kørsel i main-kilde-kode.

Det ville som udgangspunkt kunne lade sig gøre at udvikle KMR systemet med Flask kørende i main-funktionen. Dette er dog ikke hensigtmæssigt.

Jævnfør Software Design og Software Test kurset på ASE, Aarhus School of Engineering, er der dermed behov for at gøre Flask og dets endpoints mere løst koblet, således at de er i overensstemmelse med SOLID principperne anført af Robert C. Martin.

Ved brug af Blueprint-modulet er det muligt at kunne udvikle en webservice applikation med Flask i en objekt-orienteret programstruktur. Som navnet antyder, er et Blueprint, et slags billede af en operation, som kan videregives til Flask ved starten af webservicen run-time. Hermed har Flask-instansen i programmet kendskab til hvordan de endpoints ser ud, samt hvilke HTTP anmodninger der kan benyttes på disse endpoints. Dermed er det ikke en nødvendighed for applikationen at have endpoints liggende i main-funktionen. Dette gør det dermed muligt at kunne objekt-orientere hele applikationen, således at det kan designes og implementeres på lige fod med resten af KMR systemet.

\pagebreak

\section{Hjemmeside} \label{appendix::studycase::hjemmeside}

Jævnfør krav (9.2) er der fra Kamstrups side anmodet om at systemet indeholder en hjemmeside, hvis funktionalitet er at kunne fremvise data fra Database aktøren til brugeren af systemet. Hermed er dannes der grundlag for at lave research til dette krav, således et design og implementering af denne hjemmeside kan ske i henhold med kravene, så disse hermed vil blive opfyldt.

Study casen for Flask frameworket inkluderer blandt andet en lille sektion om Jinja frameworket, som kort genfortalt er en template engine. Konklusionen på denne var at Flask bl.a. er opbygget af Jinja, som sørger for HTTP forespørgsler, retur-svar og lignende. Desuden kan denne også bruges til returnering af HTML-sider. Dermed vil der ved forespørgsel på et endpoint kunne returneres en komplet HTML hjemmeside til hvor HTTP forespørgslen oprindeligt kom fra. 

Desuden vides der fra HTTP study cases at der normalt ved HTTP GET anmodes om noget. Denne HTTP GET funktionalitet kendes som sagt også fra tilgåelse af hjemmesider i en browser - eksempelvis ved tilgåelse af "Ingeniøren" hjemmeside - ing.dk. Når denne skrives ind i en browser og der trykkes "Enter", vil der blive sendt en HTTP GET forespørgsel til den tilhørende IP-adresse til domænet, efter DNS-look-up. På baggrund af dette vil man derfor kunne tilgå en HTML hjemmeside fra en browser, hvor hjemmesiden vil være returneret og hostet af en Flask service - hvilket kan lade sig gøre jævnfør Jinja.

Hermed er der grundlag for at kunne gøre brug af Flask, og dermed Jinja, til at returnere og rendere en hjemmeside til en bruger som efterspørger siden igennem en Browser.

\subsection{Bootstrap}

Med udgangspunkt i kravene for at kunne fremvise data fra Databasen igennem systemet hjemmeside er der dermed behov for research på opbygningen af en hjemmeside.

Gruppen er blevet anbefalet af kigge på Bootstrap. Dette er et gratis front-end framework, som basalt set forsøger at gøre udviklingen af en hjemmeside nemmere.
Frameworket inkluderer HTML og CSS baserede design-filer som kan benyttes til opbygningen af en hjemmeside. Disse design-filer i Bootstrap frameworket indeholder færdiglavede HTML objekter, med tilhørende stylesheets i form af CSS kode. Dermed findes der færdiglavede moduler, som endda også har tilpasset design.

For at benyttes sig af dette framework er der to muligheder:

\textbf{Content Delivery Network} \newline
Content Delivery Network, eller CDN i daglig tale, er et samlet system af flere distribuerede servere, som kan hoste og levere ressourcer som Bootstrap. Dermed kan man inkludering af nogle bestemt linjer i ens hjemmesides HTML-fil herefter benytte sig af alle Bootstraps moduler og funktionalitet. Bootstrap official CDN bliver hostet af MaxCDN og kan gratis afbenyttes. Det betyder dog at der skal være internet adgang for brugeren og hjemmesiden, således disse referencer til benyttede Bootstrap moduler kan blive hentet fra det respektive CDN.

\textbf{Lokal hosting} \newline
Såfremt man selv har server-kapacitet nok til at kunne hoste alle nødvendige Bootstrap HTML, CSS og Javascript filer, er dette også en mulighed. Hermed skal der i HTML filer refereres til de lokale Bootstrap filer stedet, således at hjemmesiden henter dem lokalt og ikke forsøger andet. Dermed er der også mulighed for, at en hjemmeside med Bootstrap elementer kan fungerer på et lukket og lokalt netværk, da der ikke skal laves anmodninger til eksterne servere.

\subsection{Ajax}
Kvag kravet om at systemets hjemmeside skal kunne fremvise data fra Databasen, er der dermed også behov for at kunne hente data til hjemmesiden, således den kan fremvises.

AJAX, Asynchronous JavaScript And XML, kan benyttes til at hente og fremvise data. Navnet er lidt misvisende da der i stedet for XMLHTTPrequests kan benyttes plain text eller JSON format til transportering og anmodning om data.

Ajax benyttes sig af funktionaliteten i brugerens browser til at anmode om data fra en eventuel server og herefter Javascript og HTML til fremvisning eller anden benyttelse af dataene på hjemmesiden.

Dette framework kan benyttes til at opdatere en hjemmeside asynkront ( som det fremgår af navnet) ved at lave anmodningerne om data bag ved igennem browseren. Dette betyder at dataene også kan benyttes og fremvises asynkront ift hjemmesiden. Hermed er der mulighed for at kunne fremvise eller behandle dataene uden at skulle genindlæse hjemmesiden igen, for at kunne få dataene frem.

En typisk AJAX applikations proces vil se ud som illustreret på figur \ref{fig:ajax_virkemaede}.

\begin{figure}[H]
	\centering{}
	\includegraphics[width = 350 pt]{img/4_Studycases/ajax.png}
	\caption{Asynchronous JavaScript And XML (AJAX) virkemåde}
	\label{fig:ajax_virkemaede}
\end{figure}

Virkemåden er desuden forklaret i tekst herunder:

\begin{enumerate}
	\item Event fremkommer ved indlæsning af hjemmeside eksempelvis - Ajax funktion kaldes.
	\item XMLHttpRequest objekt laves af Javascript.
	\item Objektet sender en HttpRequest til serveren - igennem browseren.
	\item Serveren processerer anmodningen.
	\item Serveren sender et svar tilbage til hjemmesiden/browseren.
	\item Javascriptet modtager og læser svaret.
	\item Javascriptet udfører en aktion/funktion - eksempelvis opdatering af data i en tabel.
\end{enumerate}

\pagebreak

\chapter{Klassediagrammer} \label{appendix::klassediagrammer}


I dette appendiks findes alle klassediagrammer for hele systemet. Klassediagrammerne er inddelt efter blokke under hvert respektive subsystem.

\section{Sampling}


Herunder i figur \ref{fig:sampling_class} ses et detaljeret klassediagram for Sampling subsystemet.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{Img/6_DesignImplementering/sampling_class.pdf}
	\caption{Klassediagram for Sampling subsystemet}
	\label{fig:sampling_class}
\end{figure}

\pagebreak

\subsubsection{ConfigParser}
Herunder i figur \ref{fig:configparser_class} ses et detaljeret klassediagram for ConfigParser klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/sampling/configparser_class.pdf}
	\caption{Klassediagram for ConfigParser klassen}
	\label{fig:configparser_class}
\end{figure}

\pagebreak

\subsubsection{RTLSDRInterface}
Herunder i figur \ref{fig:rtlsdrinterface_class} ses et detaljeret klassediagram for RTLSDRInterface klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/sampling/RTLSDRInterface_class.pdf}
	\caption{Klassediagram for RTLSDRInterface klassen}
	\label{fig:rtlsdrinterface_class}
\end{figure}


\pagebreak

\section{Processing}
Klassediagram for hele Processing subsystemet er valgt at blive præsenteret hvor det er brudt ned i klasser og dermed ikke vises som et samlet subsystem klassediagram. Dette skyldes at det vil være for stort at fremvise på en side.


\subsection{DBclientPC}
Herunder i figur \ref{fig:DBclientPC_class} ses et detaljeret klassediagram for DBclientPC klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/DBclientPC_class.pdf}
	\caption{Klassediagram for DBclientPC klassen}
	\label{fig:DBclientPC_class}
\end{figure}

\pagebreak

\subsection{DSP}
Herunder i figur \ref{fig:DSP_class} ses et detaljeret klassediagram for DSP klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/DSP_class.pdf}
	\caption{Klassediagram for DSP klassen}
	\label{fig:DSP_class}
\end{figure}

\pagebreak


\subsection{Channel}
Herunder i figur \ref{fig:Channel_class} ses et detaljeret klassediagram for Channel klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/Channel_class.pdf}
	\caption{Klassediagram for Channel klassen}
	\label{fig:Channel_class}
\end{figure}

\pagebreak
\subsection{Demodulator}
Herunder i figur \ref{fig:Demodulator_class} ses et detaljeret klassediagram for Demodulator klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/Demodulator_class.pdf}
	\caption{Klassediagram for Demodulator klassen}
	\label{fig:Demodulator_class}
\end{figure}

\pagebreak
\subsection{PacketDetector}
Herunder i figur \ref{fig:PacketDetector_class} ses et detaljeret klassediagram for PacketDetector klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/PacketDetector_class.pdf}
	\caption{Klassediagram for PacketDetector klassen}
	\label{fig:PacketDetector_class}
\end{figure}

\pagebreak
\subsection{Channelizer blok}
Herunder i figur \ref{fig:Channelizer_class_others} ses et klassediagram for Channelizer blokken.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/processing_channelizer_class_and_others.pdf}
	\caption{Klassediagram for Channelizer blok}
	\label{fig:Channelizer_class_others}
\end{figure}
\pagebreak

\subsection{Channelizer}
Herunder i figur \ref{fig:Channelizer_class} ses et detaljeret klassediagram for Channelizer klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/Channelizer_class.pdf}
	\caption{Klassediagram for Channelizer klassen}
	\label{fig:Channelizer_class}
\end{figure}

\pagebreak
\subsection{CICCompensator}
Herunder i figur \ref{fig:CICCompensator_class} ses et detaljeret klassediagram for CICCompensator klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/CICCompensator_class.pdf}
	\caption{Klassediagram for CICCompensator klassen}
	\label{fig:CICCompensator_class}
\end{figure}

\pagebreak
\subsection{IFMixer}
Herunder i figur \ref{fig:IFMixer_class} ses et detaljeret klassediagram for IFMixer klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/IFMixer_class.pdf}
	\caption{Klassediagram for IFMixer klassen}
	\label{fig:IFMixer_class}
\end{figure}

\pagebreak
\subsection{CICFilter}
Herunder i figur \ref{fig:CICFilter_class} ses et detaljeret klassediagram for CICFilter klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/CICFilter_class.pdf}
	\caption{Klassediagram for CICFilter klassen}
	\label{fig:CICFilter_class}
\end{figure}

\pagebreak
\subsection{CombFilter}
Herunder i figur \ref{fig:Combfilter_class} ses et detaljeret klassediagram for Combfilter klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/Combfilter_class.pdf}
	\caption{Klassediagram for Combfilter klassen}
	\label{fig:Combfilter_class}
\end{figure}
\pagebreak

\pagebreak
\subsection{Integrator}
Herunder i figur \ref{fig:Integrator_class} ses et detaljeret klassediagram for Integrator klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/Integrator_class.pdf}
	\caption{Klassediagram for Integrator klassen}
	\label{fig:Integrator_class}
\end{figure}

\pagebreak
\subsection{IQSeperator}
Herunder i figur \ref{fig:IQSeperator_class} ses et detaljeret klassediagram for IQSeperator klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/IQSeperator_class.pdf}
	\caption{Klassediagram for IQSeperator klassen}
	\label{fig:IQSeperator_class}
\end{figure}
\pagebreak

\subsection{FreqCorrector}
Herunder i figur \ref{fig:FreqCorrector_class} ses et detaljeret klassediagram for FreqCorrector klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/FreqCorrector_class.pdf}
	\caption{Klassediagram for FreqCorrector klassen}
	\label{fig:FreqCorrector_class}
\end{figure}
\pagebreak

\section{Storage blok}

Herunder i figur \ref{fig:storage_subsystem_class} ses et detaljeret klassediagram for Storage subsystemet.

\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/storage_class.pdf}
	\caption{Klassediagram for Storage subsystemet}
	\label{fig:storage_subsystem_class}
\end{figure}

\pagebreak
\subsection{Storage}
Herunder i figur \ref{fig:storage_class} ses et detaljeret klassediagram for Storage klassen.

\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/storage_itself_class.pdf}
	\caption{Klassediagram for Storage klassen}
	\label{fig:storage_class}
\end{figure}

\pagebreak
\subsection{Webservice}

Herunder i figur \ref{fig:webservice_class} ses et detaljeret klassediagram for Webservice klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/webservice_class.pdf}
	\caption{Klassediagram for Webservice klassen}
	\label{fig:webservice_class}
\end{figure}

\pagebreak
\subsection{DatabaseInterface}

Herunder i figur \ref{fig:DatabaseInterface_class} ses et detaljeret klassediagram for DatabaseInterface klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/databaseinterface_class.pdf}
	\caption{Klassediagram for DatabaseInterface klassen}
	\label{fig:DatabaseInterface_class}
\end{figure}

\pagebreak
\subsection{Collection}
Herunder i figur \ref{fig:Collection_class} ses et detaljeret klassediagram for  klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/Collection_class.pdf}
	\caption{Klassediagram for Collection klassen}
	\label{fig:Collection_class}
\end{figure}

\pagebreak
\subsection{Document}
Herunder i figur \ref{fig:Document_class} ses et detaljeret klassediagram for Document klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/document_class.pdf}
	\caption{Klassediagram for Document klassen}
	\label{fig:Document_class}
\end{figure}

\pagebreak
\section{Presentation blok}

Herunder i figur \ref{fig:Presentation_block} ses et detaljeret klassediagram for Presentation subsystemet.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/presentation/Presentation_subsystem_class.pdf}
	\caption{Klassediagram for Presentation subsystemet}
	\label{fig:Presentation_block}
\end{figure}
\pagebreak

\pagebreak
\subsection{Presentation}
Herunder i figur \ref{fig:Presentation_class} ses et detaljeret klassediagram for Presentation klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/presentation/Presentation_itself_class.pdf}
	\caption{Klassediagram for Presentation klassen}
	\label{fig:Presentation_class}
\end{figure}
\pagebreak


\subsection{Webfrontend}

Herunder i figur \ref{fig:Webfrontend_class} ses et detaljeret klassediagram for Webfrontend klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/presentation/Webfrontend_class.pdf}
	\caption{Klassediagram for Webfrontend klassen}
	\label{fig:Webfrontend_class}
\end{figure}
\pagebreak

\subsection{Index}

Herunder i figur \ref{fig:Index_class} ses et detaljeret klassediagram for selve Index klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/presentation/Index_class.pdf}
	\caption{Klassediagram for Index klassen}
	\label{fig:Index_class}
\end{figure}
\pagebreak

\subsection{Style}

Herunder i figur \ref{fig:Style_class} ses et detaljeret klassediagram for Style klassen.

Denne indeholder ingen funktioner, men i stedet en masse definitioner på stylesheetet til KMR hjemmesiden / Index.html filen.

\begin{figure}[H]
	\centering
	\includegraphics[width = 200 pt]{img/6_DesignImplementering/presentation/Style_class.pdf}
	\caption{Klassediagram for Style klassen}
	\label{fig:Style_class}
\end{figure}
\pagebreak

\subsection{DBclientServer}

Herunder i figur \ref{fig:DBclientServer_class} ses et detaljeret klassediagram for DBclientServer klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 250 pt]{img/6_DesignImplementering/presentation/DBclientServer_class.pdf}
	\caption{Klassediagram for DBclientServer klassen}
	\label{fig:DBclientServer_class}
\end{figure}
\pagebreak

\chapter{Funktionsbeskrivelser} \label{appendix::funktionsbeskrivelser}

I dette afsnit findes funktionsbeskrivelser for alle implementerede klasse i KMR systemet. For hver funktion vil der laves en specifik beskrivelse der indeholder både beskrivelser af potentielle parametre og returværdier. For mere specifikke detaljer omkring implementering af den beskrevne funktionalitet henvises til appendiks om implementering (for specielle tilfælde) eller til source koden der er vel dokumenteret af netop denne årsag.  

\subsubsection{RTLSDRInterface}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		\rowfont{\color{black}}
		set\_sample\_rate  		& Sætter samplefrekvens på RTL-SDR enhed \\
		set\_center\_freq  		& Sætter rf centerfrekvens på RTL-SDR enhed \\
		set\_freq\_correction 	& Sætter frekvens korrektion i ppm på RTL-SDR enhed \\
		read\_samples 			& Igangsætter sampling på RTL-SDR enhed og returnerer samples \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til RTLSDRInterface}
	\label{tab:func_descr_RTLSDRinterface}
\end{table}
\pagebreak 

\subsubsection{ConfigParser}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		
		get\_setup\_data 			&  \\
		get\_channels\_to\_sample 	& Indlæser, med Python configparser modulet, valget af kanaler fra setup filen \\
		get\_center\_frequencies 	& Indlæser, med Python configparser modulet, center frekvenser på de 8 kanaler, fra setup filen\\
		get\_sample\_frequency 		& Indlæser, med Python configparser modulet, sample frekvens, fra setup filen\\
		get\_modulation\_type 		& Indlæser, med Python configparser modulet, modulationstypen, fra setup filen \\
		get\_deviation\_frequncy 	& Indlæser, med Python configparser modulet, deviationsfrekvensen, fra setup filen \\
		get\_syncword 				& Indlæser, med Python configparser modulet, syncwordet, fra setup filen \\
		get\_syncword\_length 		& Indlæser, med Python configparser modulet, syncword længde, fra setup filen \\
		get\_payload\_length 		& Indlæser, med Python configparser modulet, payload længde, fra setup filen \\
		get\_receiving\_time 		& Indlæser, med Python configparser modulet, modtagetid, fra setup filen \\
		get\_frequency\_correction 	& Indlæser, med Python configparser modulet, frekvens korrektion, fra setup filen \\
		
	\end{tabu}
	\caption{Funktionsbeskrivelser til ConfigParser}
	\label{tab:func_descr_configparser}
\end{table}
\pagebreak 

\subsubsection{DBclientPC}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		push\_data & Genererer HTTP post request med kanaldata, til webservicen \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til DBclientPC}
	\label{tab:func_descr_DbclientPC}
\end{table}

\subsubsection{DSP}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		run & Opretter et antal channel klasser svarende til det der hentes med ConfigParseren. Herefter igangsætter den hver kanals processering \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til DSP}
	\label{tab:func_descr_DSP}
\end{table}

\subsubsection{Channelizer}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		plot\_filter\_response 	& Plotter filter responset for de indeholdende filtre. \\
		process 				& Igangsætter en kanalisering af det angivne signal. \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til Channelizer}
	\label{tab:func_descr_channelizer}
\end{table}
\pagebreak 

\subsubsection{Demodulator}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		calc\_filter\_delay & Beregner filter delay\\
		gen\_dec\_var 		& Generer decision variabel (positiv eller negativ fase ændring ved hvert symbol) \\
		rev\_diff\_enc 		& Udfører omvendt differentiel enkodning  \\
		rev\_nrz 			& Omvendt nrz konvertering \\
		sample\_at\_osr 	& Sampler signal ved hvert symbol\\
		plot\_dec\_points 	& Debug funktion der plotter symbolpunkter på signal \\
		create\_filter 		& Generer ønsket filter og returnerer dette \\
		gmsk\_demod 		& Demodulerer GMSK \\
		fsk\_demod 			& Demodulerer FSK \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til Demodulator}
	\label{tab:func_descr_Demodulator}
\end{table}

\subsubsection{FreqCorrector}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		adjust\_signal\_to\_baseband & Flytter et inputsignal til præcist DC. \\
		plot & Debug funktion der plotter signalet efter det er rykket  \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til FreqCorrector}
	\label{tab:func_descr_FreqCorrector}
\end{table}
\pagebreak 

\subsubsection{IQSeperator}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		seperate & Deler et komplekst input signal op i en real (I) og imaginer (Q) del. \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til IQ seperator}
	\label{tab:func_descr_IQSeperator}
\end{table}

\subsubsection{PacketDetector}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		gaussian\_turletti & Returnere et gaussisk filter anvendt til GMSK \\
		plot & Debug funktion til plot af signal \\
		nrz & Konverterer binære data til Non Return to Zero \\
		hex\_to\_binary & Konverterer binære data til hexa decimal \\
		correlate & Modtager signal og template og returnerer kolleringen af disse \\
		calc\_packet\_center & Beregner pakker center ud fra en given korrelering \\
		calc\_packet\_width & Beregner pakkebredden i samples  \\
		wave\_gen & Genererer template til korrelering efter pakker \\
		detect\_packet & Detekterer pakker og returnerer pakke samples. \\
	\end{tabu}
	\caption{Funktionsbeskrivelse PacketDetector}
	\label{tab:func_descr_PacketDetector}
\end{table}
\pagebreak 

\subsubsection{Channel}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		calc\_power & Beregner RF power ud fra IQ samples \\
		calc\_timestamp & Returnerer tidsstempel \\
		binary\_to\_hex & Konverterer binære data til hexa decimal \\
		collect\_iq & samler reel og imaginær del til komplekst signal \\
		process & Udfører samlet processering af enkelt kanal \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til Channel}
	\label{tab:func_descr_Channel}
\end{table}

\subsubsection{CICCompensator}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		define\_pass\_band & Definerer det respons kompensator filteret skal have i pasbåndet \\
		define\_stop\_band & Definerer det respons kompensator filteret skal have i stopbåndet \\
		plot\_filter\_response & Debug funktion der plotter det samlede filter respons \\
		define\_gain\_array & Returnerer array der indeholder det gain der skal defineres i pasbåndet \\
		process & Udfører kompensering ved brug af kompenseringsfilter \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til CICCompensator}
	\label{tab:func_descr_CICCompensator}
\end{table}

\subsubsection{IFMixer}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		complex\_mix\_down & Mixer signal ned ved brug en kompleks mixer \\
		real\_mix\_down & Mixer signal ned ved brug af en reel mixer \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til IFMixer}
	\label{tab:func_descr_IFMixer}
\end{table}

\subsubsection{CICFilter}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		transform\_uint64 & Transformerer signal til 64 bit unsigned integers \\
		transform\_float64 & Transformerer signal til 64 bit floats \\
		plot\_filter\_response & Debug funktion til plot af filter respons \\
		scale\_up & Skalerer signal op (se study case om channelizer) \\
		scale\_down & Skalerer signal ned (se study case om channelizer) \\
		check\_output\_bit\_size & Tjekker om channelizer gain resulterer i for stor output størrelse (se study case om channelizer) \\
		decimate & Decimerer signal \\
		calculate\_filter\_coefficients & Beregner filter koefficienter \\
		process & Proceserer signal med CIC filter \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til CICfilter}
	\label{tab:func_descr_CICfilter}
\end{table}
\pagebreak 

\subsubsection{CombFilter}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		comb & Processerer signal med comb filter  \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til CombFilter}
	\label{tab:func_descr_CombFilter}
\end{table}

\subsubsection{Integrator}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		integrate & Integrerer signal  \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til Integrator}
	\label{tab:func_descr_Integrator}
\end{table}

\subsubsection{Webservice}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		document\_api & Definerer GET og POST endpoints til dokumenter. Kalder DatabaseInterface funktioner på de givne endpoints \\
		collection\_api & Definerer GET endpoint til collection. Kalder DatabaseInterface funktion på endpointet \\
		register\_endpoints & Registrer endpoints med Blueprint (se study case om Blueprint) \\
		add\_document & Funktion der kaldes ved POST forespørgsel på dokument API. Kalder DatabaseInterface funktionen: create\_document \\
		get\_document & Funktion der kaldes ved GET forespørgsel på dokument API. Kalder DatabaseInterface funktionen: collect\_document\\
		clear\_document & Funktion der kaldes ved GET forespørgsel på collection API. Kalder DatabaseInterface funktionen: delete\_document \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til Webservice}
	\label{tab:func_descr_webservice}
\end{table}
\pagebreak 

\subsubsection{DatabaseInterface}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		create\_document & Indsætter dokument i den eksterne database \\
		collect\_documents & Loader dokumenter fra den eksterne database \\
		delete\_collection & Sletter alle dokumenter i den eksterne database \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til DatabaseInterface}
	\label{tab:func_descr_databaseinterface}
\end{table}

\subsubsection{Collection}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		count\_documents & Returnerer antallet af dokumenter i den givne collection på den eksterne database \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til Collection}
	\label{tab:func_descr_collection}
\end{table}

\subsubsection{Webfrontend}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ m{4cm}  m{8.5cm} }
		\cellcolor{tableTitleHeader}\color{white}\bfseries Navn &\cellcolor{tableTitleHeader}\color{white}\bfseries Beskrivelse \\
		index\_api & Definerer endpoint til HTML koden. \\
		index & Returenere HTML kode på GET forespørgsel på endpointet index. \\ 
		register\_endpoints & Registrer endpoints med Blueprint (se study case om Blueprint) \\
	\end{tabu}
	\caption{Funktionsbeskrivelse til Webfrontend}
	\label{tab:func_descr_webfrontend}
\end{table}

\subsubsection{DBclientServer}
DBclientServer er som bekendt implementeret i Javascript og er ikke oprettet med reelle funktioner. Ved load af hjemmeside oprettes data tabel som fyldes med data ved hjælp af et HTTP GET forespørgsel der sendes hvert sekund til webservicen.
\pagebreak 


\chapter{Subsystem sekvensdiagrammer} \label{appendix::subsystem_sekvensdiagrammer}

I dette appendiks findes alle sekvensdiagrammer for alle subsystemer. Sekvensdiagrammerne er under hver deres respektive subsystem.

\pagebreak

\section{Sampling}
Herunder i figur \ref{fig:configparser_sequence} ses sekvensdiagrammet for ConfigParser og RTLSDRInterface.
\begin{figure}[H]
	\centering
	\includegraphics[width = 350 pt]{img/6_DesignImplementering/sampling/Sampling_configparser_sequence.pdf}
	\caption{Sekvensdiagram for ConfigParser og RTLSDRInterface klassen}
	\label{fig:configparser_sequence}
\end{figure}


\pagebreak


\section{Processing}
\subsection{DBclientPC}
Herunder i figur \ref{fig:DBclientPC_sequence} ses et sekvensdiagram for DBclientPC klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/Processing_dbclient_sequence}
	\caption{Sekvensdiagram for DBclientPC klassen}
	\label{fig:DBclientPC_sequence}
\end{figure}

\pagebreak

\subsection{DSP}
Herunder i figur \ref{fig:DSP_sequence} ses et sekvensdiagram for DSP klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/Processing_dsp_sequence}
	\caption{Sekvensdiagram for DSP klassen}
	\label{fig:DSP_sequence}
\end{figure}

\pagebreak

\subsection{Channel}
Herunder i figur \ref{fig:Channel_sequence} ses et sekvensdiagram for Channel klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/Processing_channel_sequence}
	\caption{Sekvensdiagram for Channel klassen}
	\label{fig:Channel_sequence}
\end{figure}

\pagebreak
\subsection{Demodulator}
Herunder i figur \ref{fig:Demodulator_sequence} ses et sekvensdiagram for Demodulator klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 320 pt]{img/6_DesignImplementering/processing/Processing_demodulator_sequence}
	\caption{Sekvensdiagram for Demodulator klassen}
	\label{fig:Demodulator_sequence}
\end{figure}

\pagebreak
\subsection{PacketDetector}
Herunder i figur \ref{fig:PacketDetector_sequence} ses et sekvensdiagram for PacketDetector klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 320 pt]{img/6_DesignImplementering/processing/Processing_packetdetector_sequence}
	\caption{Sekvensdiagram for PacketDetector klassen}
	\label{fig:PacketDetector_sequence}
\end{figure}

\pagebreak
\subsection{Channelizer}
Herunder i figur \ref{fig:Channelizer_sequence} ses et sekvensdiagram for Channelizer klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/processing/Processing_channelizer_sequence}
	\caption{Sekvensdiagram for Channelizer klassen}
	\label{fig:Channelizer_sequence}
\end{figure}
\pagebreak
\subsection{IQSeperator}
Herunder i figur \ref{fig:IQSeperator_sequence} ses et sekvensdiagram for IQSeperator klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 250 pt]{img/6_DesignImplementering/processing/Processing_iqseperator_sequence}
	\caption{Sekvensdiagram for IQSeperator klassen}
	\label{fig:IQSeperator_sequence}
\end{figure}
\pagebreak
\subsection{FreqCorrector}
Herunder i figur \ref{fig:FreqCorrector_sequence} ses et sekvensdiagram for FreqCorrector klassen.
\begin{figure}[H]
	\centering
	\includegraphics[width = 250 pt]{img/6_DesignImplementering/processing/Processing_freqcorrector_sequence}
	\caption{Sekvensdiagram for FreqCorrector klassen}
	\label{fig:FreqCorrector_sequence}
\end{figure}

\pagebreak

\section{Storage}

Herunder i figur \ref{fig:Storage_sequence} ses et sekvensdiagram for initiering af Storage subsystemet.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/storage_sequence_initialize.pdf}
	\caption{Sekvensdiagram for initiering af Storage subsystemet}
	\label{fig:Storage_sequence}
\end{figure}

\pagebreak
\subsection{Add document}

Herunder i figur \ref{fig:Storage_add_document_sequence} ses et sekvensdiagram for tilføjelse af et dokument i Databasen igennem Storage subsystemet.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/storage_sequence_add_document.pdf}
	\caption[Sekvensdiagram for Add document]{Sekvensdiagram for tilføjelse af et dokument i Databasen igennem Storage subsystemet}
	\label{fig:Storage_add_document_sequence}
\end{figure}

\pagebreak
\subsection{Get documents}

Herunder i figur \ref{fig:Storage_get_documents_sequence} ses et sekvensdiagram for download af alle dokumenter i Databasen igennem Storage subsystemet.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/storage_sequence_get_documents.pdf}
	\caption[Sekvensdiagram for Get documents]{Sekvensdiagram for download af alle dokumenter i Databasen igennem Storage subsystemet}
	\label{fig:Storage_get_documents_sequence}
\end{figure}

\pagebreak
\subsection{Clear collection}
Herunder i figur \ref{fig:Storage_clear_collection_sequence} ses et sekvensdiagram for at clear collection i Databasen igennem Storage subsystemet.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/storage/storage_sequence_clear_collection.pdf}
	\caption[Sekvensdiagram for Clear collection]{Sekvensdiagram for at clear collection i Databasen igennem Storage subsystemet}
	\label{fig:Storage_clear_collection_sequence}
\end{figure}

\pagebreak
\section{Presentation}

Herunder i figur \ref{fig:presentation_init_sequence} ses et sekvensdiagram for initiering af Presentation subsystemet.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/presentation/presentation_sequence_initialize.pdf}
	\caption{Sekvensdiagram for initiering af Presentation subsystemet}
	\label{fig:presentation_init_sequence}
\end{figure}

\pagebreak

\subsection{Webfrontend}

Herunder i figur \ref{fig:presentation_webfrontend_sequence} ses et sekvensdiagram for Browser indlæsning af KMR systemets hjemmeside igennem Webfrontend i Presentation subsystemet.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/presentation/presentation_sequence_load_webpage.pdf}
	\caption[Sekvensdiagram for Hjemmeside indlæsning]{Sekvensdiagram for indlæsning af KMR systemets hjemmeside igennem Presentation subsystemet}
	\label{fig:presentation_webfrontend_sequence}
\end{figure}

\pagebreak

\subsection{DBclientServer}

Herunder i figur \ref{fig:presentation_dbclientserver_sequence} ses et sekvensdiagram for DBclientServer der henter data hvert sekund, igennem Storage subsystemet, og fremviser dette til brugeren igennem Browse.
\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/6_DesignImplementering/presentation/presentation_sequence_refresh.pdf}
	\caption{Sekvensdiagram for DBclientServer}
	\label{fig:presentation_dbclientserver_sequence}
\end{figure}

\pagebreak

\chapter{Implementeringsværktøjer} \label{appendix::implementeringsvaerktoojer}

For at koble det design og de implementeringsdetaljer der er blevet defineret i henholdsvis klasseidentifikation, metodeidentifikation og klasseinteraktion, til egentlig kode, er der en række værktøjer der skal bruges. I det følgende vil disse listes og det vil overvejes, hvorledes de enkelte værktøjer kan bidrage til transaktionen mellem software design og egentlig software. 

\subsubsection{PyCharm}
For at kunne skrive den Python kode der er defineret ud fra software klaser og tilhørende metoder, skal der anvendes en editor, der er designet til at skrive Python kode. Her er der flere tilgængelige, men grundet tidligere erfaring anvendes Python IDE'en PyCharm udviklet af Jetbrains. Denne IDE tillader at skrive Python kode, og har en god måde at strukturer de forskellige filer der oprettes. I og med KMR systemet kodebase vil være objektorienteret vil der være mange filer at skulle holde styr på, da der er blevet bestræbt efter at holde hver fil, til at indeholde en enkelt klasse definering.

\subsubsection{Git}
Git er et værktøj der anvendes til versionsstyring. Versionsstyring sikrer at der kan påføres en agil og iterativ tilgang til kode udvikling. Netop af denne årsag anvendes Git. Derudover tillader den måde Git håndterer sammenfletning af kode stykker at det er muligt at være flere personer om udvikling, uden den store kompleksitet. Dette er en stor fordel i forhold til udviklingsprocessen.

\subsubsection{Sublime Text 3}
Da der i Presentation subsystemet skal udvikles både HTML, CSS og Javascript kode, er det nødvendigt med en editor, andet en Pycharm (denne fokuserer på Python kode). Da der ikke var behov for nogen voldsom strukturering, eller andet der kunne diktere grundlaget for en mere dedikeret editor, benyttes blot Sublime Text 3 til udvikling af web kode.

\subsubsection{Google Chrome udviklingsværktøj}
I forhold til at kunne debugge udviklingen af HTML, CSS og Javascript koden kan ikke blot anvendes en normal debugger som det kendes fra triviel kode skrivning. Da denne form for kode skal vises gennem en browser, vil det også være i browseren at runtime fejl og detaljer vil afsløres. Derfor skal anvendes et debug miljø der kan findes igennem en browser. Da kravene omkring visualisering af data dikterer anvendelse af Google Chrome browseren, anvendes derfor den indbyggede Google Chrome udviklingsværktøj. Denne kan åbnes gennem Chrome browseren og tilbyder et velkendt debug miljø til web udviklings kode. 

\subsubsection{MongoDB compass}
I forhold til bruges af MongoDB database som ekstern aktør, anvendes MongoDB compass til at holde styr på indholdet af databasen. Dette er fordelagtigt i forbindelse med debugging af anvendelsen af MongoDB databasen.

\subsubsection{Postman}
Postman er et stykke software der anvendes til at generer HTTP forespørgsler. Inden udviklingen af Python kode der kan gøre det samme, har postman været anvendt til generering af disse forespørgsler i forbindelse med udvikling af webservicen til den eksterne database. 

\pagebreak

\chapter{Implementeringseksempler} \label{appendix::implementeringseksempler}

\subsubsection{Matched filter til demodulering}
\begin{python}
	def create_filter(self, ts, filter):
	h = []
	
	if filter.lower() == '1rec':
	# Standard MSK filter
	t = np.arange(0, self.osr * 2 + 1) * ts
	h = np.sin(np.pi * t / 2 / self.T)
	
	elif filter.lower() == '2rec':
	# 2REC filter (Mengali p.153 ex. 4.2.2)
	t = np.arange(0, self.osr * 3 + 1) * ts
	h = (1 + np.sqrt(2) * np.sin(np.pi * (t - self.T / 2) / self.T / 2)) / 2 / np.sqrt(2)
	
	return h
\end{python}

\subsubsection{Korrelering efter pakker med template}
\begin{python}
	
	def correlate(self, corr_wave, sig, fir_taps):
	
	correlation = np.correlate(corr_wave, sig, "same")
	correlation *= 1 / np.max(correlation)
	self.plot(correlation, "correlation")
	
	w = self.calc_packet_width(96)
	peaks = []
	
	while True:
	
	peak = np.argmax(correlation)
	peak = (peak - fir_taps / 2)
	peaks.append(peak)
	
	mask = np.ones(len(correlation))
	mask[int(peak - (w/2)):int(peak + (w/2))] = 0
	correlation *= mask
	
	if np.max(correlation) < 0.5:
	break
	
	return np.asarray(peaks)
\end{python}

\pagebreak
\subsubsection{Filter response for channelizer kompenseringsfilter}
\begin{python}
	def define_gain_array(self, f_pass, f_stop):
	
	g_pass = np.ones(len(f_pass))
	g_pass[1:] = abs((self.cic_m * self.cic_r * np.sin(np.pi * f_pass[1:]) / self.cic_r) /
	(np.sin(np.pi * self.cic_m * f_pass[1:]))) ** self.cic_n
	
	# Let stop band be all zeroes
	g_stop = np.zeros(len(f_stop))
	
	# Complete gain array of pass and stopband
	gain_array = np.concatenate([g_pass, g_stop])
	
	return gain_array
\end{python}

\subsubsection{Registrering af blueprints til objektorienteret Webservice}
\begin{python}
	def register_endpoints(self):
	
	# Get document_api blueprint and registering it to app Flask instance.
	document_blueprint = self.document_api()
	self.app.register_blueprint(document_blueprint)
	
	# Get collection_api blueprint and registering it to app Flask instance.
	collection_blueprint = self.collection_api()
	self.app.register_blueprint(collection_blueprint)
	
	# Checking if both blueprints and its endpoints has successfully been registered.
	if (document_blueprint._got_registered_once != True) and (collection_blueprint._got_registered_once != True):
	print("Failure in Storage: Initialization was not successfull - Program exits")
	sys.exit()
	else:
	print("Storage: Succesfully setup Webservice and bridge to mongoDB database")
	
\end{python}

\pagebreak
\subsubsection{Interface til MongoDB Database i Storage subsystemmet}
\begin{python}
	
	def create_document(self):
	
	# Gathering the data which comes with the POST request.
	meter_id = request.json['meter_id']
	channel_number = request.json['channel_number']
	channel_frequency = request.json['channel_frequency']
	timestamp = request.json['timestamp']
	signal_strength = request.json['signal_strength']
	payload = request.json['payload']
	
	# Creating new document with the gathered data
	__document = Document(payload, meter_id, timestamp, signal_strength, channel_frequency, channel_number)
	
	try:
	# Creating a unique ID to the newly created document
	document_id = self.__collection.
	collection_db.insert(
	{'meter_id': __document.meter_id_temp,
		'channel_number': __document.channel_number_temp,
		'channel_frequency': __document.channel_frequency_temp,
		'timestamp': __document.timestamp_temp,
		'signal_strength': __document.signal_strength_temp,
		'payload': __document.payload_temp})
	
	# Uploading the document with the unique ID to the MongoDB database
	new_document = self.__collection.collection_db.find_one({'_id': document_id})
	
	return "Storage: Successfully added document to mongoDB database"
	
	except Exception:
	error = "Failure in Storage: Document was not uploaded to mongoDB database - it might be offline"
	print(error)
	return error
	
\end{python}

\pagebreak

\subsubsection{DBclientServer, implementeret i Javascript}
\begin{lstlisting}
$(document).ready(function() {
//Bootstraps DataTable
var table = $('#mydatatable').DataTable();


// DBclientServer (all below)
setInterval(function() {	
$.ajax({
url: "http://192.168.1.66:5100/document"
}).then(function(data) {
console.log(data)
table.clear().draw()
$.each(data.data, function(index, item) {
table.row.add([item.meter_id, item.channel_number, 
item.channel_frequency, item.timestamp, 
item.signal_strength, item.payload]).draw(false)
});
});
}, 1000);
} );

\end{lstlisting}

\pagebreak

\chapter{Implementeringsdetaljer} \label{appendix::implementeringsdetaljer}

\section{Serverdetaljer}
Server delen af systemet er allokeret på en Raspberry Pi 3b. Hermed agerer Storage og Presentation subsystemet herfra. Der er ikke tvivl om at, set ud fra performance, ville der være bedre alternativer. Gruppen vurderede dog, at der ville være et større overhead ved at have serveren stående off-site. Ved projektets start blev der med Kamstrup diskuteret om server-plads ved dem, men eftersom at der alligevel ikke ville være behov for sikkerhed på serveren ville ulemperne vægte tungere end fordelene. Det samme ville være gældende for en server ved en tredjepart. Fordelene ved at have serveren i samme lokale som implementeringen af systemet og gruppemedlemmerne har været at der hurtigt og nemt kunne implementeres nye ting, pushe nye versioner af systemet samt opdateringer af andre moduler mm. Alt dette ville tidsmæssigt have et større overhead ved eventuelt at skulle logge ind med VPN eller andre sikkerhedsforanstaltninger forinden at kunne gøre det ønskede ved serveren. Derfor har det blot været en ARM-processor som har stået for server-delen af KMR systemet. Ved en eventuel skalering af KRM systemet ville det være smart at allokere denne på en server med flere kerner og mere hukommelse.

Serveren, Raspberry Pi, har desuden implementeret den eksterne aktør: Database. Denne MongoDB database er implementer med apt-get kald i terminal på serveren og kører med default indstillinger udover oprettede collections, som bliver brugt undervejs i implementeringen og test af systemmet og dets subsystemer.
MongoDB installationen på serveren af version 2.4.14, da de nyere 3.X versioner ikke endnu findes til ARM-baserede processore. Dette skyldes, ifølge MongoDB, nogle kode-komplikationer som gøre at de nyere versioner ikke kan kompiles til denne type af processorer.

\section{Netværksopsætning}
Grundet allokeringen af KMR systemets subsystemer på to forskellige enheder: PC og server, har det været nødvendigt at have et netværk, Jf. krav om netværk, således at disse har kommunikere. Netværket der har været brugt i projeket har været et lokalt lukket netværk, som ingen internetadgang har haft. Netværket hedder "KMR\_NETWORK" og er implementeret med en WPA2 sikkerhed, således at netværket har været uforstyrret af eventuelle gæster. Netværket har igennem 2.4 GHz WiFi fungeret som bro imellem subsystemerne Sampling og Processing på PC-delen og Storage og Presentation på Server-delen.

Da den eksterne aktør, Database, og Webservice skal kunne tilgås på nogle prædefinerede statiske adresser og porte har det været nødvendigt at definere disse i netværksindstillingerne på den pågældende router, således at test af systemet og dets subsystemer ville kunne genskabes med samme resultat.
Herunder ses de adresser og porte som er prædefineret for systemet for at sikre dets virke på det lokale netværk.

\begin{tabular}{ p{4cm} | p{8cm} }
	Webservice & localhost:5100 \\ \\
	Webfrontend & localhost:5200 \\ \\
	MongoDB database & localhost:27017 \\ \\
	Server (Raspberry Pi) & 192.168.1.67 \\ \\
\end{tabular}

Da både Webservicen, i form af Storage subsystemet, Webfrontenden, i form af Presentation subsystemet, og MongoDB databaseinstansen, i form af Database aktøren for systemet, er allokeret på serveren ville klienter på samme lukkede lokale netværk kunne kontakte disse blokke. Hermed kan DBclientPC fra Processing subsystemet tilgå MongoDB databasen ved at skrive til Webservicen på følgende adresse og port: 192.168.1.67:5100. Hermed forwarder routeren forespørgslen til Raspberry Pi'en, serveren, som herefter kigger efter en service som kører på den angivne port, hvilket i dette tilfælde ville være Webservicen. Her modtager Webservice forespørgslen og ved en hardcodede IP-adresse tilgår den MongoDB databasen på serverens localhost port 27017 og foretager de operationer der er nødvendige.

\pagebreak


\chapter{Systemmeddelelser} \label{appendix::systemmeddelelser}
I forbindelse med de sekvensdiagrammer der er oprettet i interaktionsdefinitionen i designet af KMR systemet, er der påført en række af systemmeddelelser. Disse systemmeddelelser er alle beskeder som systemet vil kunne udskrive til brugeren såfremt en given undtagelse blive rejst. For at lette udtrykket af sekvensdiagrammerne, er disse blot påført nogle generiske beskeder. Disse beskeder vil i nedenstående tabel udskrives således disse kan matches med de prints der reelt opleves når KMR systemet aktiveres og anvendes. 

\textbf{Systemmeddelelser - Sampling og Processing} \\ \\
\begin{tabular}{ p{6cm} | p{6cm} }
	\textbf{Sampling} 		        & \\ \\
	(1) SamplingErrorMessage1	    & (1.1) Failure in Sampling: To many channels set \newline \newline (1.2) Failure in Sampling: Channel 1 center frequency out of ISM band - Program exits. \newline \newline (1.3) Failure in Sampling: Sample frequency too high - Program exits. \newline \newline (1.4) Failure in Sampling: Unknown modulation type - Program exits. \\ \\
	(2) Usecase1Exception3aMessage  & (2.1) Error in interfacing with RTL-SDR - Program exits. \\ \\
	
	
	\textbf{Processing} 	        & \\ \\
	(1) ProcessingMessage1		    & (1.1) Decoding and upload was successful - Program exits. \\ \\
	(2) Usecase2Exception1aMessage  & (2.1) No packets was registered - Program exits. \\ \\
	(3) Usecase2Exception2aMessage  & (3.1) Error in uploading to Database - Program exits. \\ \\
\end{tabular}  

\pagebreak
\textbf{Systemmeddelelser - Storage og Presentation} \\ \\
\begin{tabular}{ p{6cm} | p{6cm} }
	\textbf{Storage} 			    & \\ \\
	(1) StorageErrorMessage1 		& (1.1) Failure in Storage: Initialization was not successfull - Program exits. \\ \\
	(2) StorageMessage1 			& (2.1) Storage: Succesfully setup Webservice and bridge to mongoDB database. \\ \\
	(3) StorageErrorMessage2		& (3.1) Failure in Storage: Document was not uploaded to mongoDB database - check Database status. \\ \\
	(4) StorageMessage2 			& (4.1) Storage: Successfully added document to mongoDB database. \\ \\
	(5) Usecase3Exception5aMessage 	& (5.1) Error in getting data from Database - check Database status. \\ \\
	(6) StorageMessage3 			& (6.1) documents\_output \newline \newline (6.2) Storage: No documents where found in the collection in the mongoDB database. The collection is empty. \\ \\
	(7) StorageErrorMessage4 		& (7.1) Failure in Storage: Collection and its document was not cleared from mongoDB database - it might be offline. \\ \\
	(8) StorageMessage4 			& (8.1) Storage: Database has been successfully cleared \newline \newline (8.2) Storage: Collection is already cleared - no further action is taken. \\ \\
	
	\textbf{Presentation} 	        & \\ \\
	(1) PresentationMessage1	    & (1.1) Presentation: Succesfully setup webfrontend. \\ \\
	(2) PresentationErrorMessage1   & (2.1) Failure in Presentation: Initialization was not successfull - Program exits. \\ \\
\end{tabular}

\pagebreak

\chapter{Testsignal generering} \label{appendix::testsignal_generering}
I forbindelse med udførsel af såvel udviklingstest som accepttests er der som følge af en af de givne risici fra RISK tabellen taget et valg i samarbejde med Kamstrup, om at anvende et simuleret signal som input til systemet. Da der på tidspunktet for test, endnu ikke er udviklet en IOT4M måler der vil kunne anvendes som transmitter, er det ikke muligt at teste systemet på den måde det ellers var planlagt. Derfor generes i stedet et testsignal der efterligner det signal der ellers ville samples med Sampling subsystemet til KMR systemet. 

Testsignalet generes ud fra viden indhentet om såvel pakkeindhold som GMSK modulering. Pakkeindholdet vil for det generede testsignal ikke indeholde alle de samme felter som det ellers er kendt fra pakkeindholdet jævnfør dennes study case. Da KMR projektet er afgrænset fra dekodningen af pakkerne vil denne kodning ikke tilføjes testsignalet. Af samme årsag vil alle de felter i pakken der anvendes til dekodning heller ikke medtages. Dette vil sige pakken udelukkende vil bestå af preamble syncword og den reelle dataframe. 

Længden af dataframen er jævnfør study casen om pakkeindhold 96 bytes. Dette nedsættes for testsignalet af illustrative årsager på frontenden. Både preamble syncword og dataframe sættes til 32 bit hver. 

Moduleringen af signalet sker på baggrund af viden indhentet fra GMSK study casen. Datasekvensen af preamble syncword og dataframe sættes sammen for derefter at NRZ konverteres. NRZ dataene oversamples derefter ud fra den kendte samplefrekvens og datarate hvorefter der genereres et fasedrej på 90 grader (pi halve) for hvert bit. Fasedrejets retning er afhængig af det givne data punkt. Med fasen generet kan signalet frekvens moduleres efter Eulers formel til den givne kanalfrekvens. 

Moduleringen sker for hver kanal, hvorefter de enkelte kanaler samles i ét signal. Den signalstyrke der ligger i signalet, er bundet op på den spænding der er givet for de sinus og cosinus bølger der indgår i frekvens moduleringen. Såfremt signalet ønskes stærkere, kan disse bølgers spænding forøges. 

Testsignalet vil indeholde støj. Der vil indgå støjsamples både mellem hver pakke i signalet, samt pålægges støj over hele signalet. De samples der indlægges mellem pakkerne bruges til at adskille disse for at efterligne en transmission hvor pakkerne ikke sendes lige efter hinanden. De støjsamples der pålægges hele signalet, skal simulere den støj der vil opfanges gennem transmissionen. Da støjen der pålægges hele signalet, er kendt ligeså vel som signal styrken på det egentlige signal er kendt, kan signal støj forholdet beregnes som beskrevet i ligning \ref{snr}. 

\begin{equation} \label{snr}
	SNR_{db} = 10 * log_{10}(\frac{P_{signal}}{P_{noise}}) 
\end{equation}     

Signal støj forholdet kan anvendes i forbindelse med test af hvor robust den udviklede modtage algoritme er, overfor potentiel støj, i forbindelse med transmittering af signalet. Et eksempel på hvordan testsignalet generes i Python kan ses nedenstående.

\begin{python}
	# Create preamble and syncword
	preamble = tx.hex_to_binary(0xAAAAAAAA)
	syncword = tx.hex_to_binary(0x91B39CEB)
	
	# Create packets for transmission
	payload1 = tx.hex_to_binary(0xBBBBBBBB)
	payload2 = tx.hex_to_binary(0xCCCCCCCC)
	payload3 = tx.hex_to_binary(0xDDDDDDDD)
	payload4 = tx.hex_to_binary(0xEEEEEEEE)
	payload5 = tx.hex_to_binary(0xFFFFFFFF)
	payload6 = tx.hex_to_binary(0xABABABAB)
	payload7 = tx.hex_to_binary(0xCDCDCDCD)
	payload8 = tx.hex_to_binary(0xEFEFEFEF)
	
	# Concatenate packets with preamble and syncword 
	testdata1 = np.concatenate((preamble, syncword, payload1)).astype(int)
	testdata2 = np.concatenate((preamble, syncword, payload2)).astype(int)
	testdata3 = np.concatenate((preamble, syncword, payload3)).astype(int)
	testdata4 = np.concatenate((preamble, syncword, payload4)).astype(int)
	testdata5 = np.concatenate((preamble, syncword, payload5)).astype(int)
	testdata6 = np.concatenate((preamble, syncword, payload6)).astype(int)
	testdata7 = np.concatenate((preamble, syncword, payload7)).astype(int)
	testdata8 = np.concatenate((preamble, syncword, payload8)).astype(int)
	
	
	# Modulate individual channels
	sig1, delay1 = tx.gmsk_modulate(testdata1, if_freq=30000)        
	sig2, delay2 = tx.gmsk_modulate(testdata2, if_freq=70000)
	sig3, delay3 = tx.gmsk_modulate(testdata3, if_freq=110000)
	sig4, delay4 = tx.gmsk_modulate(testdata4, if_freq=150000)
	sig5, delay5 = tx.gmsk_modulate(testdata5, if_freq=450000)
	sig6, delay6 = tx.gmsk_modulate(testdata6, if_freq=490000)
	sig7, delay7 = tx.gmsk_modulate(testdata7, if_freq=530000)
	sig8, delay8 = tx.gmsk_modulate(testdata8, if_freq=570000)
	
	# Collect channels
	sig = sig1 + sig2 + sig3 + sig4 + sig5 + sig6 + sig7 + sig8
	
	# Calculate power of signal 
	v_peak = np.average(np.sqrt(sig.real ** 2 + sig.imag ** 2))
	v_rms = v_peak / np.sqrt(2)
	p_rms = (v_rms ** 2) / 50
	p_dbm = 30 + (10 * np.log10(p_rms))
	
	# Create noise
	noise_between = np.random.normal(0, 1, 100000)
	noise_sig = np.random.normal(0, 1, 2248750)
	noise_sig *= 10
	noise_between = noise_between / np.max(noise_between)  # Normalize noise
	
	# Calculate SNR
	calc_snr(noise_sig, np.real(sig))
	
	# Collect signal and noise
	sig = np.concatenate([noise_between, sig, noise_between])
	sig = np.tile(sig, [10])
	sig += noise_sig
\end{python}

\pagebreak

\chapter{Udviklingstest} \label{appendix::test}

\section{Testmiljø} 
Testmiljøet beskriver det setup der skal være at finde omkring de udførte tests for at sikrer at det resultat der er fundet af testen i forbindelse med KMR systemets test, kan genskabes. Testmiljøet vil beskrive versionsnumre på anvendt software, beskrive det præcise hardware der er anvendt, samt det område hvor testen er udført og eventuelle struktur specifikke detaljer.

Testmiljøet vil være givet for alle de, i KMR systemet udførte, tests. Såfremt noget testopsætning afviger fra dette miljø, vil den enkelte afvigelse kunne findes i testproceduren til den enkelte test.

\subsubsection{Testsignal}
Testsignalet anvendes til at efterligne det output der vil være fra Sampling subsystemet. Argumentet for brug af dette testsignal kan findes i integrationstesten mellem Sampling og Processing. Mere information om genereringen af testsignalet kan findes i \ref{appendix::testsignal_generering}.

\begin{itemize}
	\item Preample: 0xAAAAAAAA
	\item SyncWord: 0x91B39CEB
	\item Payload (kanal 1): 0xBBBBBBBB
	\item Payload (kanal 2): 0xCCCCCCCC
	\item Payload (kanal 3): 0xDDDDDDDD
	\item Payload (kanal 4): 0xEEEEEEEE
	\item Payload (kanal 5): 0xFFFFFFFF
	\item Payload (kanal 6): 0xABABABAB
	\item Payload (kanal 7): 0xBCBCBCBC
	\item Payload (kanal 8): 0xEFEFEFEF
\end{itemize} 

\pagebreak

\textbf{Python- og Python-modul-versioner} \\

Python-moduler og deres versionsnummer, som er installeret til brug af KMR systemet kan ses i tabel \ref{tab:acceptest_python}.
Der har også været flere andre moduler der har været benyttet. Disse er dog indbygget i Python 3.7 distributionen og derfor behøver de ikke at installeres sideløbende.

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{4cm}   p{4cm} }
		\multicolumn{2}{c}{\cellcolor{tableTitleHeader}\color{white}\bfseries Python- og Python-modul-versioner} \\
		\tableHeaderStyle
		Navn & Version\\
		Python & 3.7.0 \\
		pyrtlsdr & 0.2.9 \\
		scipy & 0.19.1  \\
		Flask & 0.12.1  \\
		requests & 2.18.4  \\
		Flask\_PyMongo & 2.1.0  \\
		Flask\_Cors & 3.0.3  \\
		Flask\_Bootstrap & 3.3.7.1  \\
		numpy & 1.13.3  \\
		pymongo & 3.7.1  \\
		matplotlib & 2.2.3 \\
		sympy & 1.3 \\
	\end{tabu}
	\caption{Python- og Python-modul-versioner}
	\label{tab:acceptest_python}
\end{table}


\textbf{PC hardware og software} \\
Alle tests bliver udført på en specifik PC.
Specifikationer på PC'en, samt dens hardware og styresystem kan ses i tabel \ref{tab:acceptest_pc_hardware_software}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{6cm}   p{6cm} }
		\multicolumn{2}{c}{\cellcolor{tableTitleHeader}\color{white}\bfseries PC hardware og software} \\
		Computermærke & Dell \\
		Modelnavn & XPS 9570 - CNX97003  \\
		Serienummer & 5LQVLQ2 \\
		Styresystem & Windows 10 Home 64bit - version: 1803 \\
	\end{tabu}
	\caption{PC hardware og software til accepttests}
	\label{tab:acceptest_pc_hardware_software}
\end{table}


\textbf{Specifikationer på afsenderen: LimeSDR} \\
Der bruges en specifik afsender som kaldes LimeSDR til at generere bærebølger.
Gruppen har lavet et script til at generere ved brug af enheden. Dette script kan findes under navnet: "tx.py".
Specifikationerne for denne afsender kan ses i tabel \ref{tab:acceptest_test_tx_module}.

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{6cm}   p{6cm} }
		\multicolumn{2}{c}{\cellcolor{tableTitleHeader}\color{white}\bfseries Specifikationer på afsenderen: LimeSDR} \\
		%\tableHeaderStyle
		Afsender enhed & Lime microsystems LimeSDR \\
		Afsender serienummer & 0009060B00491338 \\
		Antenne interface & SMA \\
	\end{tabu}
	\caption{Afsender enhed}
	\label{tab:acceptest_test_tx_module}
\end{table}


\textbf{ConfigParser indstillinger} \\
I accepttest af usecase 1, Sample data, bruges der specifikke værdier i ConfigParser indstillingsdokumentet. Disse indstillinger bliver brugt til at vise at Sampling subsystemet er funktionelt til at kunne sample efter bærebølger. På nuværende tidspunkt har Kamstrup ikke en komplet færdigudviklet protokol og signal. Derfor kan vi ikke replikere det ufærdige signal og bruge i test af systemet og dermed accepttests.

Dermed er der grundlag for at vise at systemet kan registrere og sample bærebølgerne, hvilket leder os til at disse værdier i tabel
 \ref{tab:acceptest_test_case_config_parser_indstillinger} bliver brugt. I og med der samples efter bærebølger i forbindelse med test af usecase 1, vil mange indstillinger ikke anvendes. Derfor udelades disse fra tabellen.

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{6cm}   p{6cm} }
		\multicolumn{2}{c}{\cellcolor{tableTitleHeader}\color{white}\bfseries ConfigParser indstillinger} \\
		%\tableHeaderStyle
		CHANNELS\_TO\_SAMPLE & 12345678 \\
		CENTER\_FREQUENCY\_CHANNEL\_1 & 868.03 \\
		CENTER\_FREQUENCY\_CHANNEL\_2 & 868.07 \\
		CENTER\_FREQUENCY\_CHANNEL\_3 & 868.11 \\
		CENTER\_FREQUENCY\_CHANNEL\_4 & 868.15 \\
		CENTER\_FREQUENCY\_CHANNEL\_5 & 868.45 \\
		CENTER\_FREQUENCY\_CHANNEL\_6 & 868.49 \\
		CENTER\_FREQUENCY\_CHANNEL\_7 & 868.53 \\
		CENTER\_FREQUENCY\_CHANNEL\_8 & 868.57 \\
		SAMPLE\_FREQUENCY & 2500000 \\
	\end{tabu}
	\caption{Brugte ConfigParser værdier til accepttests af usecase 1 - Sample data}
	\label{tab:acceptest_test_case_config_parser_indstillinger}
\end{table}

\textbf{Specifikationer på modtageren RTL-SDR} \\
I accepttesten bruges modtageren RTL-SDR til at sample efter bærebølgesignalerne. Enheden og antennen er som sagt givet af Kamstrup og dermed et krav til systemet.
Specifikationer på denne enhed kan ses i \ref{tab:acceptest_test_case_rtlsdr}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{6cm}   p{6cm} }
		\multicolumn{2}{c}{\cellcolor{tableTitleHeader}\color{white}\bfseries Specifikationer på modtageren RTL-SDR} \\
		%\tableHeaderStyle
		Modtager enhed & RTL-SDR V3 R820T2 RTL2832U \\
		Modtager serienummer & 000000001 (Vendor Specific) \\
		Antenne interface & SMA \\
	\end{tabu}
	\caption{RTL-SDR modtager enhed}
	\label{tab:acceptest_test_case_rtlsdr}
\end{table}

\pagebreak

\textbf{Pakkestruktur fra Databasen til KMR systemets hjemmeside} \\
I accepttesten bruges der en bestemt pakkestruktur fra Databasen til KMR systemets hjemmeside, således værdierne ikke bliver placeret forkert.
Et eksempel på denne struktur kan ses i tabel \ref{tab:acceptest_test_case_pakkestruktur}.

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{6cm}   p{6cm} }
		\multicolumn{2}{c}{\cellcolor{tableTitleHeader}\color{white}\bfseries Pakkestruktur - dataobjekt til webservice og databasen} \\
		%\tableHeaderStyle
		Meter ID & 4 bytes \\
		Channel number & "Channel 1-8" \\
		Channel frequency & "868.03 MHz" \\	
		Timestamp & "12:01:03" \\
		Signalstrength & -60 dBm \\
		Payload & 8 bytes \\
	\end{tabu}
	\caption{Pakkestrukturen fra Databasen til KMR systemets hjemmeside}
	\label{tab:acceptest_test_case_pakkestruktur}
\end{table}

\pagebreak

Server-delen af KMR systemet er allokeret på en server-platformen i modsætning til PC-delen af KMR systemet, som kører på PC'en beskrevet i tabel \ref{tab:acceptest_pc_hardware_software}. Serveren har allokeret "Server.py" delen af KMR systemet på sin platform og specifikationer for denne hardware og software som bruges til allokeringen af denne KMR system del kan ses i tabel \ref{tab:acceptest_test_case_server}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{6cm}   p{6cm} }
		\multicolumn{2}{c}{\cellcolor{tableTitleHeader}\color{white}\bfseries Server-platform} \\
		%\tableHeaderStyle
		Server model & Raspberry Pi 3b \\
		Processor arkitektur & ARMv7 rev 4 (v71) \\
		Serienummer & 0000000003457921 \\
		Tilsluttet WiFi & "KMR\_NETWORK" \\
	\end{tabu}
	\caption{Server-platform til accepttest}
	\label{tab:acceptest_test_case_server}
\end{table}

KMR systemet kræver netværk for at kunne kommunikere på tværs af PC og server delen igennem TCP/IP. Hermed ses der i figur \ref{tab:acceptest_test_case_network} hvilket type netværk, router og indstillinger denne har haft.

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{6cm}   p{6cm} }
		\multicolumn{2}{c}{\cellcolor{tableTitleHeader}\color{white}\bfseries Netværk} \\
		%\tableHeaderStyle
		Router model & HomeBox V 5DK45-01 \\
		Netværktype & Lokalt \\
		SSID 2.4 GHz & "KMR\_NETWORK" \\
		SSID 2.4 GHz password & "KMRKMRKMR" \\
		Serienummer & LK15211DP340052 \\
		Statisk IP & Server-platformen har tildelt IP-addressen 192.168.1.67 \\
	\end{tabu}
	\caption{Netværk til accepttest}
	\label{tab:acceptest_test_case_network}
\end{table}

\textbf{Test miljø} \\
Denne accepttest bliver udført på en specifik lokation.
Specifikationer for denne lokation kan ses i tabel \ref{tab:acceptest_test_case_UC2_test_miljoe}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  p{6cm}   p{6cm} }
		\multicolumn{2}{c}{\cellcolor{tableTitleHeader}\color{white}\bfseries Test miljø} \\
		%\tableHeaderStyle
		Land & Danmark \\
		By & Aarhus N  \\
		Adresse & Finlandsgade 22 \\
		Aarhus Universitets bygningsnummer & 5126 \\
		Lokale & 246K \\	
	\end{tabu}
	\caption{Test-miljø til accepttest}
	\label{tab:acceptest_test_case_UC2_test_miljoe}
\end{table}


\pagebreak

\pagebreak
\section{Test procedure}

I det følgende beskrives test proceduren for samtlige udviklingstest udført i forbindelse med KMR systemet. 

\subsection{Unittests}

\paragraph{RTLSDRInterface} \mbox{}\\
\begin{enumerate}
	\item Kør "RTLSDRInterface\_test.py" med Python 3.7
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\paragraph{ConfigParser} \mbox{}\\
\begin{enumerate}
	\item Kør "ConfigParser\_test.py" med Python 3.7
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\paragraph{DSP} \mbox{}\\
\begin{enumerate}
	\item Kør "DSP\_test.py" med Python 3.7
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\paragraph{DBclientPC} \mbox{}\\
\begin{enumerate}
	\item Kør "DBclientPC\_test.py" med Python 3.7
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\pagebreak
\paragraph{Webservice} \mbox{}\\
\begin{enumerate}
	\item Kør "Webservice\_test.py" med Python 3.7
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\paragraph{DatabaseInterface} \mbox{}\\
\begin{enumerate}
	\item Start en MongoDB database ved navn: "test".
	\item Verificer at MongoDB databasen er tilgængelig på //localhost:27017/, som den er ved default opsætning.
	\item Kør "DatabaseInterface\_test.py" med Python 3.7.
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\paragraph{Webfrontend} \mbox{}\\
\begin{enumerate}
	\item Kør "Webfrontend\_test.py" med Python 3.7.
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes test 1-4 med dets forventede resultat og det faktiske resultat
	\item Start en Browser.
	\item Test 5 eksekveres ved at tilgå "localhost:5200" endpointet i Browseren.
	\begin{enumerate}
		\item Tryk på F12 for at tilgå Chrome-udvikler-vinduet.
		\item Tryk på Network-fanen i Chrome-udvikler-vinduet. Fanen igangsættes automatisk til at optage alle netværksaktiviteter - og dermed indhentning af filer igennem localhost-netværket.
		\item Tryk på F5 for at gen-indlæse siden.
		\item Sammenlign hvorvidt der som minimum indhentes de samme filer som i tabel \ref{tab:unittest_webfrontend_test_5_fil_liste}.
	\end{enumerate}
\end{enumerate}

\pagebreak
\paragraph{DBclientServer} \mbox{}\\
\begin{enumerate}
	\item Kør "DBclientServer\_test.py" med Python 3.7.
	\item Start en Chrome-Browser-instans, som fungerer som Browser aktøren.
	\item Gå til "localhost:5200".
	\item Tryk på F12 for at tilgå Chrome-udvikler-vinduet.
	\item Tryk på Network-fanen i Chrome-udvikler-vinduet. Fanen igangsættes automatisk til at optage alle netværksaktiviteter - og dermed indhentning af filer igennem localhost-netværket.
	\item Efter 5 sekunder trykkes der på "Stop recording network log" eller "Ctrl + E".
	\item Filteret sættes til "XHR" fremfor "All".
	\item Den horisontale tidslinje, som er defineret med anmærkninger ved hver sekund i enheden millisekunder, indstilles til at stå imellem 0 millisekunder og 3000 millisekunder.
	\item Der tælles "document"-objekter i tabellen, under tidslinjen. Antallet af disse "document"-objekter er outputtet af denne test. 
\end{enumerate}

\pagebreak

\subsection{Integrationstests}

Alle integrationstest fra blokke til subsystemer findes i stien herunder, under hvert respektive subsystem: \newline
\path{Tests\Udviklingstest\Integration\Integration_internal}

\subsubsection{Subsystem integration}

\paragraph{Sampling} \mbox{}\\

\begin{enumerate}
	\item Kør "sampling\_test.py" med Python 3.7
	\item Ved færdigkørsel sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\paragraph{Processing} \mbox{}\\
Ved integrationstest af Processing subsystemet bruges testsignalet "ProcessingIntegrationTest.npy".

\begin{enumerate}
	\item Kør "processing\_test.py" med Python 3.7
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\paragraph{Storage} \mbox{}\\

\begin{enumerate}
	\item Kør "storage\_test.py" med Python 3.7
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\paragraph{Presentation} \mbox{}\\
Da DBclientServer ikke er en separat klasse, men en del af det JS-script som allerede er testet at kan blive hentet af Webfrontenden, vil integrationen mellem disse to klasser allerede være opnået. Derfor udføres ikke nogen decideret intern integrationstest i Presentation subsystemet.

\subsubsection{Kobling af subsystemer}

\paragraph{Sampling \& Processing} \mbox{}\\
\begin{enumerate}
	\item Kør "sampling\_processing.py" med Python 3.7
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}

\paragraph{Sampling, Processing \& Storage} \mbox{}\\
\begin{enumerate}
	\item Kør "sampling\_processing\_storage.py" med Python 3.7
	\item Ved færdigkørsel udskrives testresultaterne automatisk.
	\item Her sammenlignes hver test med dets forventede resultat og det faktiske resultat.
\end{enumerate}


\pagebreak
\section{Testresultater}
I det følgende vil præsenteres testresultat tabeller for test udviklingstest udført i forbindelse med KMR systemet. Hver test vil have en kort beskrivelse, et input, et forventet resultat og et faktisk resultat, fundet ved udførsel af test. Enkelte test vil kræve en ekstra tabel til præsentation af et input eller et forventet output.

\subsection{Unittests}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{3 cm} p{3 cm} p{3 cm} p{3 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Unittest - RTLSDRInterface} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: Set samplefrequency & 2.4e6 & 2.4e6 & 2.4e6 \\
		
		Test 2: Set center frequency & 50e3 & 50e3 & 50e3 \\
		
		Test 3: Set frequency correction & 60 & 60 & 60 \\
		
		Test 4: Read specified number of samples & 1000 & 1000 & 1000 \\
		
	\end{tabu}
	\caption{Unittest tabel: RTLSDRInterface}
	\label{tab:unittest_rtlsdr}
\end{table}
\pagebreak

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{3 cm} p{3 cm} p{3 cm} p{3 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Unittest - ConfigParser} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: Get channels to sample  & 12345678 & [1, 2, 3, 4, 5, 6, 7, 8] & [1, 2, 3, 4, 5, 6, 7, 8] \\
		
		Test 2: Get center frequency channel 1  & 866.7 & 866.7 & 866.7 \\
		
		Test 3: Get center frequency channel 2 & 866.9 & 866.9 & 866.9 \\
		
		Test 4: Get center frequency channel 3 & 867.1 & 867.1 & 867.1 \\

		Test 5: Get center frequency channel 4 & 867.3 & 867.3 & 867.3 \\
		
		Test 6: Get center frequency channel 5 & 867.5 & 867.5 & 867.5 \\
		
		Test 7: Get center frequency channel 6 & 867.7 & 867.7 & 867.7 \\
		
		Test 8: Get center frequency channel 7  & 867.9 & 867.9 & 867.9 \\
		
		Test 9: Get center frequency channel 8  & 868.1 & 868.1 & 868.1 \\
		
		Test 10: Get sample frequency & 2500000 & 2500000 & 2500000 \\
		
	\end{tabu}
	\caption{Unittest tabel: ConfigParser}
	\label{tab:unittest_configparser}
\end{table}
\pagebreak

\paragraph{DSP}
DSP'en resultat af unittest vil udskrives i en konsol og det er valideret at det faktiske output afspejler dig i det forventede som ses af nedenstående tabel.
\begin{table}[H]
	\centering
	\begin{tabular}{l}
		\{ \\
		'ch1': ['Packet 1: ABDC', 'Packet 2: ABDC', 'Packet 3: ABDC'], \\
		'ch2': ['Packet 1: AAEC', 'Packet 2: AAEC', 'Packet 3: AAEC'] \\
		\} \\
	\end{tabular}
	\caption{Unittest af DSP - Test 1: Demodulate data - Forventet output}
	\label{unittest_DSP_test_1_forventet_otput}
\end{table}

\pagebreak
\paragraph{DBclientPC}
DBclientPC anvender en datastruktur, som ses af \ref{unittest_dbclient_pc_test_1_input}, som input. Med denne som parameter kan testen udføres med det resultat der ses af tabel \ref{tab:unittest_db_client_pc}.
\begin{table}[H]
	\centering
	\begin{tabular}{l}
		\{ \\
		'payload': 'impl', 'meter\_id': 'impl', \\
		'timestamp': 'impl', 'signal\_strength': 'impl', \\
		'channel\_frequency': 'impl', 'channel\_number': 'impl' \\
		\} \\
	\end{tabular}
	\caption{Unittest af DBclientPC - Input til Test 1: Dataupload through HTTP PUT}
	\label{unittest_dbclient_pc_test_1_input}
\end{table}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{3 cm} p{3 cm} p{3 cm} p{3 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Unittest - DBclientPC} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: Dataupload through HTTP POST  & Tabel \ref{unittest_dbclient_pc_test_1_input} & 200 & 200  \\
		
	\end{tabu}
	\caption{Unittest tabel: DBclientPC}
	\label{tab:unittest_db_client_pc}
\end{table}
\pagebreak


\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{3 cm} p{3 cm} p{3 cm} p{3 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Unittest - Webservice} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: document\_api  & Funktionskald af den testede funktion & 'flask.blueprints.Blueprint' & 'flask.blueprints.Blueprint'  \\
		
		Test 2: collection\_api  & Funktionskald af den testede funktion & 'flask.blueprints.Blueprint' & 'flask.blueprints.Blueprint'  \\
		
		Test 3: register\_endpoints  & Funktionskald af den testede funktion med resultaterne af Test 1 og 2 som argumenter  & True & True  \\
		
		Test 4: GET /document  & HTTP GET request & 200 & 200  \\
		
		Test 5: POST /document  & HTTP POST request & 200 & 200  \\
		
		Test 6: GET /collection  & HTTP GET request & 200 & 200  \\
		
	\end{tabu}
	\caption{Unittest tabel: Webservice}
	\label{tab:unittest_webservice}
\end{table}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{3 cm} p{3 cm} p{3 cm} p{3 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Unittest - DatabaseInterface} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: \newline Add document to MongoDB  & Funktionskald: \newline
		create\_document(\newline
		"meter\_id",\newline
		"channel\_number",\newline
		"channel\_frequency",\newline
		"timestamp",\newline
		"signal\_strength",\newline
		 "payload") &
		 
		 "Successfully added document to mongoDB database" & "Successfully added document to mongoDB database"  \\
		
		Test 2: \newline Collect documents from MongoDB  & Funktionskald: \newline collect\_documents() & "Documents where found in the collection in the mongoDB database" & "Documents where found in the collection in the mongoDB database" \\
		
		Test 3: \newline Delete collection from mongoDB  & Funktionskald: \newline delete\_collection  & "Database has been successfully cleared" & "Database has been successfully cleared"  \\
		
	\end{tabu}
	\caption{Unittest tabel: DatabaseInterface}
	\label{tab:unittest_Database}
\end{table}
\pagebreak

\begin{table}[H]
	\centering
	\begin{tabular}{l}
		bootstrap.min.css \\
		dataTables.bootstrap4.min.css \\
		style.css \\
		jquery-3.3.1.min.js \\
		bootstrap.min.js \\
		jquery.dataTables.min.js \\
		dataTables.bootstrap4.min.js \\
		DBclientServer.js \\
		Roboto-Regular.ttf \\
		favicon.ico \\
	\end{tabular}
	\caption{Unittest af Webfrontend - Test 5 - Liste af filer som index.html henter efter at blive loadet fra "localhost:5200" endpointet.}
	\label{tab:unittest_webfrontend_test_5_fil_liste}
\end{table}


\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{3 cm} p{3 cm} p{3 cm} p{3 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Unittest - Webfrontend} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: index\_api  & Funktionskald af den testede funktion & 'flask.blueprints.Blueprint' & 'flask.blueprints.Blueprint'  \\
		
		Test 3: register\_endpoints  & Funktionskald af den testede funktion med resultaterne af Test 1 & True & True  \\
		
		Test 3: HTML status code & HTTP GET request på "localhost:5200" & 200 & 200  \\
		
		Test 4: HTML text  & HTTP GET request på "localhost:5200" & "ACCPTED" & "ACCEPTED"  \\
		
		Test 5: Download af index.html's tilhørende filer  & HTTP GET request på "localhost:5200" igennem Chrome Browser & Forventet output er beskrevet under test proceduren, som også henviser til tabel \ref{tab:unittest_webfrontend_test_5_fil_liste} & Faktiske output ses i figur \ref{fig:dbclientserver}.  \\
		
	\end{tabu}
	\caption{Unittest tabel: Webfrontend}
	\label{tab:unittest_webfrontend}
\end{table}
\pagebreak

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{3 cm} p{3 cm} p{3 cm} p{3 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Unittest - DBclientServer} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: HTTP GET kald  & Brugeren tilgår "localhost:5200" i Browseren  & Antal af "documents": & Antal af "documents": 3  \\
		
	\end{tabu}
	\caption{Unittest tabel: DBclientServer}
	\label{tab:unittest_DBclientServer}
\end{table}
\pagebreak

\subsection{Integrationstests}

\paragraph{Sampling} \mbox{}\\

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{2.5 cm} p{2.5 cm} p{2.5 cm} p{2.5 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Integrationstest - Sampling} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: Indhent indstillinger og sample ud fra disse  & Kørsel af sampling\_test.py & PSD plot der viser 8 kanaler som henholdsvis er placeret ved: \newline
		868.0 MHz, \newline
		868.1 MHz, \newline
		868.3 MHz, \newline
		868.4 MHz, \newline
		868.5 MHz, \newline
		868.6 MHz, \newline
		868.7 MHz, \newline & PSD plot der viser 8 kanaler som henholdsvis er placeret ved: \newline
		868.0 MHz, \newline
		868.1 MHz, \newline
		868.3 MHz, \newline
		868.4 MHz, \newline
		868.5 MHz, \newline
		868.6 MHz, \newline
		868.7 MHz, \newline \\
		
	\end{tabu}
	\caption{Integrationstest tabel: Sampling}
	\label{tab:integration_sampling}
\end{table}

\paragraph{Processing} \mbox{}\\

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{2.5 cm} p{2.5 cm} p{2.5 cm} p{2.5 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Integrationstest - Processing} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: Processering af samples og upload af data  & Kørsel af Processing\_test.py & Systemet udskriver i konsollen: "Decoding and upload was successful": & "Decoding and upload was successful"  \\
		
	\end{tabu}
	\caption{Integrationstest tabel: Processing}
	\label{tab:integration_processing}
\end{table}
\pagebreak

\paragraph{Storage} \mbox{}\\

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{2.5 cm} p{2.5 cm} p{2.5 cm} p{2.5 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Integrationstest - Storage} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: POST /document endpoint - Tilføj data-objekt til Databasen  & Kørsel af storage\_test.py & Systemet udskriver i konsollen: "Test 1 status: ACCEPTED": & "Test 1 status: ACCEPTED"  \\
		
		Test 2: GET /document endpoint - Hent data-objekter fra Databasen  & Kørsel af storage\_test.py & Systemet udskriver i konsollen: "Test 2 status: ACCEPTED": & "Test 2 status: ACCEPTED"  \\
		
		Test 3: GET /collection endpoint - Slet collection og dens tilhørende data & Kørsel af storage\_test.py & Systemet udskriver i konsollen: "Test 3 status: ACCEPTED": & "Test 3 status: ACCEPTED"  \\
		
	\end{tabu}
	\caption{Integrationstest tabel: Storage}
	\label{tab:integration_storage}
\end{table}

\paragraph{Presentation} \mbox{}\\
Da DBclientServer ikke er en separat klasse, men en del af det Javascript som allerede er testet at kan blive hentet af Webfrontenden, vil integrationen mellem disse to klasser allerede være opnået. Derfor udføres ikke nogen decideret intern integrationstest i Presentation subsystemet.

\pagebreak

\paragraph{Sampling \& Processing} \mbox{}\\
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{2.5 cm} p{2.5 cm} p{2.5 cm} p{2.5 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Integrationstest - Sampling \& Processing} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: Sampling og Processing  & Kørsel af sampling\_processing.py & Systemet udskriver i konsollen: "Decoding and upload was successfull" & "Decoding and upload was successfull"   \\
		
	\end{tabu}
	\caption{Integrationstest tabel: Sampling \& Processing}
	\label{tab:integration_sampling_processing}
\end{table}


\paragraph{Sampling, Processing \& Storage} \mbox{}\\
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{2.5 cm} p{2.5 cm} p{2.5 cm} p{2.5 cm}  }
		\multicolumn{4}{c}{\cellcolor{usecaseTitleHeader}\color{white}\bfseries Integrationstest - Sampling, Processing \& Storage} \\
		\usecaseHeaderStyle
		Test & Input & Forventet output & Faktisk output\\
		
		Test 1: Sample, Processing og Storage med data  & Kørsel af sampling\_processing\_storage.py & Systemet udskriver i konsollen: "Test 1: ACCEPTED" & "Test 1: ACCEPTED"   \\
		
		Test 2: Validering af data & Kørsel af sampling\_processing\_storage.py & Systemet udskriver i konsollen: "Test 2: ACCEPTED" & "Test 2: ACCEPTED" \\ 
		
	\end{tabu}
	\caption{Integrationstest tabel: Sampling, Processing \& Storage}
	\label{tab:integration_sampling_processing_storage}
\end{table}


\chapter{Accepttest - Guideline} \label{appendix::accepttest_guideline}

I forbindelse med udførsel af accepttest, vil det være nødvendigt for en given testperson at kende til den procedure der er omkring udførsel af de givne tests. Af dette grund er defineret disse guidelines, der beskriver hvorledes accepttests skal køres, samt de eventuelle udvidelser der vil være til udførslen i forhold til den beskrevne usecase. De eventuelle udvidelse vil være fundet gennem den udvikling der har været af systemet, som har defineret en ny viden der bidrager til systemets ageren. 

I forbindelse med usecase 1 er der gennem udvikling fundet frem til brugen af en configparser til indlæsning af bruger input. Som det ses af de sekvensdiagrammer der er udviklet til dette scenarie, er der tilføjet en undtagelseshåndtering ved indlæsningen. Dette medfører et ekstra print i forbindelse med usecasen idet det printet når dataene er indlæst korrekt. 

\pagebreak

\subsubsection{Usecase 1 - Sample data} 


\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  c  p{11cm} }
		\multicolumn{2}{c}{\cellcolor{guidelineTitleHeader}\color{white}\bfseries Guideline til hovedscenarie} \\
		\guidelineHeaderStyle
		Punkt & Udførelse\\
		Prækondition & Indsæt RTL-SDR enheden i USB-A porten på PC'en\\
		
		Punkt 1 & Naviger til Test/Accepttests/Usecasetests/utils/Sampling og åben setup.ini hvor indstillinger kan skrives til systemet. \\
		
		Punkt 2 & Kør systemet ved at køre usecase\_1\_test.py med Python 3. \\
		
		Punkt 3 & Der printes en status meddelelse for indlæsningen fra ConfigParser. \\
		
		Punkt 4	& Følger usecase beskrivelsen \\
		
	\end{tabu}
	\caption{Guideline tabel: Usecase 1 - Sample data - Hovedscenarie}
	\label{tab:guideline_use_case_1_sample_data_hovedscenarie}
\end{table}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  c  p{11cm} }
		\multicolumn{2}{c}{\cellcolor{guidelineTitleHeader}\color{white}\bfseries Guideline til udvidelse 3a} \\
		\guidelineHeaderStyle
		Punkt & Udførelse\\
		
		Prækondition & Fjern den tilsluttede RTL-SDR enhed \\
		
		Punkt 1 	& Naviger til Test/Accepttests/Usecasetests \\
		
		Punkt 2		& Kør systemet ved at køre usecase\_1\_test.py med Python 3. \\		
		
	\end{tabu}
	\caption{Guideline tabel: Usecase 1 - Sample data - Udvidelse 3a}
	\label{tab:guideline_use_case_1_sample_data_udvidelse_3a}
\end{table}

\pagebreak

\subsubsection{Usecase 2 - Process data}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  c  p{11cm} }
		\multicolumn{2}{c}{\cellcolor{guidelineTitleHeader}\color{white}\bfseries Guideline til hovedscenarie} \\
		\guidelineHeaderStyle
		Punkt & Udførelse\\
		
		Prækondition 		& Der anvendes testsignalet "testsignal\_accepttest" som indkommende samples \\
		Prækondition		& Start en instans af MongoDB på localhost:27017 \\
		Prækondition		& Naviger til Test/Accepttests/Usecasetests og kør server.py \\
		Punkt 1  			& Naviger til Test/Accepttests/Usecasetests og kør usecase\_2\_test.py  \\
		Punkt 2				& Følger usecase beskrivelsen \\ 
		Punkt 3	 			& Følger usecase beskrivelsen \\
		Punkt 4				& Følger usecase beskrivelsen \\
	\end{tabu}
	\caption{Guideline tabel: Usecase 2 - Process data - Hovedscenarie}
	\label{tab:guideline_use_case_2_process_data_hovedscenarie}
\end{table}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  c  p{11cm} }
		\multicolumn{2}{c}{\cellcolor{guidelineTitleHeader}\color{white}\bfseries Guideline til udvidelse 1a} \\
		\guidelineHeaderStyle
		Punkt & Udførelse\\
		
		Prækondition	& Der anvendes testsignalet "testsignal\_accepttest\_u1a" som indkommende samples \\
		
		Prækondition	& Naviger til Test/Accepttests/Usecasetests og kør usecase\_2\_u1a\_test.py  \\
		
	\end{tabu}
	\caption{Guideline tabel: Usecase 2 - Process data - Udvidelse 1a}
	\label{tab:guideline_use_case_2_process_data_udvidelse1a}
\end{table}

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  c  p{11cm} }
		\multicolumn{2}{c}{\cellcolor{guidelineTitleHeader}\color{white}\bfseries Guideline til udvidelse 2a} \\
		\guidelineHeaderStyle
		Punkt & Udførelse\\
		
		Prækondition	& Deaktiver MongoDB database instansen \\
		
		Prækondition 	& Naviger til Test/Accepttests/Usecasetests og kør usecase\_2\_test.py  \\
		
	\end{tabu}
	\caption{Guideline tabel: Usecase 2 - Process data - Udvidelse 2a}
	\label{tab:guideline_use_case_2_process_data_udvidelse2a}
\end{table}

\pagebreak
\subsubsection{Usecase 3 - Present data}
\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  c  p{11cm} }
		\multicolumn{2}{c}{\cellcolor{guidelineTitleHeader}\color{white}\bfseries Guideline til hovedscenarie} \\
		\guidelineHeaderStyle
		Punkt & Udførelse\\
		
		
		Prækondition		& Naviger til Test/Accepttests/Usecasetests og kør server.py \\
		Prækondition		& Start en instans af MongoDB på localhost:27017 \\
		Punkt 1				& Følger usecase beskrivelsen \\
		Punkt 2				& Følger usecase beskrivelsen \\
		Punkt 3	 			& Følger usecase beskrivelsen \\
		Punkt 4				& Følger usecase beskrivelsen \\
		Punkt 5				& Følger usecase beskrivelsen \\
		Punkt 6				& Følger usecase beskrivelsen \\
		Punkt 7				& Følger usecase beskrivelsen \\ 
		
		
	\end{tabu}
	\caption{Guideline tabel: Usecase 3 - Present data - Hovedscenarie}
	\label{tab:guideline_use_case_3_present_data_hovedscenarie}
\end{table}


\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  c  p{11cm} }
		\multicolumn{2}{c}{\cellcolor{guidelineTitleHeader}\color{white}\bfseries Guideline til udvidelse 3a} \\
		\guidelineHeaderStyle
		Punkt & Udførelse\\
		
		Prækondition		& Sluk server.py \\
		
	\end{tabu}
	\caption{Guideline tabel: Usecase 3 - Present data - Udvidelse 3a}
	\label{tab:guideline_use_case_3_present_data_udvidelse_3a}
\end{table}


\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{  c  p{11cm} }
		\multicolumn{2}{c}{\cellcolor{guidelineTitleHeader}\color{white}\bfseries Guideline til udvidelse 5a} \\
		\guidelineHeaderStyle
		Punkt & Udførelse\\
		
		Prækondition		& Deaktiver MongoDB instansen \\
		
	\end{tabu}
	\caption{Guideline tabel: Usecase 3 - Present data - Udvidelse 5a}
	\label{tab:guideline_use_case_3_present_data_udvidelse_5a}
\end{table}

\chapter{Accepttest - Yderligere krav} \label{appendix::yderligere_krav}

Med udgangspunkt i de opstillede yderligere krav fra Kamstrup vil der i dette afsnit blive afdækket test af disse krav. Det er ikke alle krav der vil blive testet, men såfremt et krav har en betydning for KMR systemet performance, vil det pågældende krav blive testet i dette afsnit. Kravene der henvises til er de "Yderligere krav til systemet" som er defineret i Specifikations-afsnittet rapporten. \\

Da mange af de performance-orienterede krav i forvejen er testet undervejs i integrations-test, systemtest og selve accepttestene, vil der derfor i denne test-sektion være fokus på de resterende krav som endnu ikke er blevet testet. Hermed vil vi efterfølgende kunne verificere at KMR systemet lever op til de yderligere krav til ydeevnen for systemet. \\

\pagebreak

\textbf{Test af krav 5.2} \\
I testen af krav 5.2 i tabel \ref{tab:acceptest_yderligere_krav_signal_stoj_forhold} vil der blive testet for om systemet kan demodulere et simuleret signal, hvori signalet ligger med et signal-støj-forhold på 9 dB. Hermed vil der blive verificeret at systemet kan demodulere succesfuldt ved dette signal-støj-forhold, således at systemet overholder det opsatte krav.

Der benyttes et generet/simuleret signal, "SNR9dB.npy", til denne test, hvor der bliver kørt gaussisk støj indover således at signal-støj-forholdet ender med at blive 9 dB. I testen vil der blive forsøgt at detektere kanaler på samme måde som i hovedscenariet i usecase 2.

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{1.0 cm}  p{4.5 cm}   p{4.5 cm}   c  }
		\multicolumn{4}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries Krav 5.2 - Demodulering skal være succesfuld ved et signal-støj-forhold på 9 dB} \\
		\kravHeaderStyle
		Punkt & Test procedure & Forventet resultat & Godkendt?\\
		
		1 & Kør "snr\_test.py" med Python 3.7 & Konsollen udskriver: \newline "SNR test: ACCEPTED" & \vtop{\hbox{\strut [ \hspace*{0.1cm} ] Ja}\hbox{\strut }\hbox{\strut [ \hspace*{0.1cm} ] Nej}} \\
		
	\end{tabu}
	\caption{Yderligere krav - Signal-støj-forhold}
	\label{tab:acceptest_yderligere_krav_signal_stoj_forhold}
\end{table}

Herunder i figur \ref{fig:krav_5_2_snr} ses det at programmet udskriver "SNR test: ACCEPTED", hvilket konkluderer at testen er succesfuldt accepteret. Testen er succesfuld da alle pakkerne bliver korrekt demoduleret og der dermed ikke opstår en undtagelse undervejs i systemet.

\begin{figure}[H]
	\centering{}
	\fbox{\includegraphics[width = 370 pt]{img/7_test/yderligere_krav_5_2_SNR.png}}
	\caption{Test af krav 5.2 - Resultat}
	\label{fig:krav_5_2_snr}
\end{figure}

\pagebreak

\textbf{Test af krav 7.4} \\
I testen af krav 7.4 i tabel \ref{tab:acceptest_yderligere_krav_pakke_demodulering} vil der blive testet for om systemet kan demodulere 10 pakker, fra én kanal, indenfor 1 sekunder. Hermed vil der blive verificeret at systemet overholder ydeevne-grænsen for demoduleringen, således at systemet består dette krav.

Der benyttes et generet/simuleret signal, hvori der ligger henholdsvis 8 kanaler med 10 pakker hver. Her bliver der demoduleringen kørt på hver enkelte kanal, hvoraf den samlede tid der bruges på hver kanal ved demodulering udskrives. Til sidst bliver der i testen tjekket hvorvidt nogle af kanaler tog 1 sekund eller mere om at fuldføre demoduleringsprocessen for den pågældende kanal. Hvis dette ikke er tilfældet, er testen succesfuldt accepteret.

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{1.0 cm}  p{4.5 cm}   p{4.5 cm}   c  }
		\multicolumn{4}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries Krav 7.4 - Radiosignal-delen skal kunne demodulere minimum 10 pakker indenfor} \\
		\multicolumn{4}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries  1 sekunder pr. kanal.} \\
		\kravHeaderStyle
		Punkt & Test procedure & Forventet resultat & Godkendt?\\
		
		1 & Kør "package\_demod\_test.py" med Python 3.7 & Konsollen udskriver: \newline "Package demod test: ACCEPTED" & \vtop{\hbox{\strut [ \hspace*{0.1cm} ] Ja}\hbox{\strut }\hbox{\strut [ \hspace*{0.1cm} ] Nej}} \\
		
	\end{tabu}
	\caption{Yderligere krav - Pakke-demodulering}
	\label{tab:acceptest_yderligere_krav_pakke_demodulering}
\end{table}

Resultatet for test af krav (7.5) ses herunder i figur \ref{fig:krav_7_5_demod_resultat}. Der bliver omtrent brugt 7-8 sekunder for demodulering af 10 pakker på én kanal. Dermed er testen ikke succesfuld. For diskussion af denne henvises der til rapportens diskussion og resultat afsnit.


\begin{figure}[H]
	\centering{}
	\fbox{\includegraphics[width = 150 pt]{img/7_test/yderligere_krav_7_5_demod.png}}
	\caption{Test af krav 7.4 - Resultat}
	\label{fig:krav_7_5_demod_resultat}
\end{figure}

\pagebreak

\textbf{Test af krav 8.3} \\
I testen af krav (8.3) i tabel \ref{tab:acceptest_yderligere_krav_upload_ydeevne} vil der blive testet for om systemet kan uploade 5 data-objekter til Databasen på maksimum 1 sekund. Test-scriptet, "data\_upload\_test.py", bruger samme data-objekt 5 gange, som forsøges uploades til Databasen på kortest tid muligt, igennem Storage-subsystemet. Lige inden den første data-pakker bliver sendt afsted tages system-tiden og ligeledes når den sidste pakke er sendt afsted. Herefter tages forskellen af disse tider for at verificere at testen er udført på under 1 sekund. Hermed vil der blive verificeret at systemet overholder ydeevne-grænsen for upload af data-objekter til Databasen, hvilket resulterer i at systemet vil bestå dette krav.

Testen udføres, hvor server-delen af KMR systemet kører på Serveren, som er defineret som Raspberry Pi 3b. "DataDownload\_test.py" scriptet bliver kørt på en PC som er på samme netværk som Serveren - "KMR\_NETWORK".

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{1.0 cm}  p{4.5 cm}   p{4.5 cm}   c  }
		\multicolumn{4}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries Krav (8.3) - Systemet skal kunne håndtere upload af 5 data-objekter i sekundet} \\
		\kravHeaderStyle
		Punkt & Test procedure & Forventet resultat & Godkendt?\\
		
		1 & Kør "DataUpload\_test.py" med Python 3.7 & Konsollen udskriver: \newline "Data upload test: ACCEPTED" & \vtop{\hbox{\strut [ \hspace*{0.1cm} ] Ja}\hbox{\strut }\hbox{\strut [ \hspace*{0.1cm} ] Nej}} \\
		
	\end{tabu}
	\caption{Yderligere krav - Upload ydeevne}
	\label{tab:acceptest_yderligere_krav_upload_ydeevne}
\end{table}

Herunder i figur \ref{fig:krav_8_3_dataupload} ses resultatet for testen af krav (8.3). Hermed kan det konkluderes at systemet uden problemer kan håndtere upload af 5 pakker i sekundet.

\begin{figure}[H]
	\centering{}
	\fbox{\includegraphics[width = 370 pt]{img/7_test/yderligere_krav_8_3_dataupload.png}}
	\caption{Test af krav 8.3 - Resultat}
	\label{fig:krav_8_3_dataupload}
\end{figure}

\pagebreak

\textbf{Test af krav (8.4)} \\
I testen af krav (8.4) i tabel \ref{tab:acceptest_yderligere_krav_upload_ydeevne} vil der blive testet for om systemet kan downloade 5 data-objekter fra Databasen på maksimum 1 sekund.  Test-scriptet, "DataUpload\_test.py", opsættes til at tage system-tiden lige inden der anmodes om data fra Databasen igennem Storage-subsystemet. Efter den anmodede data er modtaget, tages der igen en system-tid, således differencen af de to kan beregnes. Såfremt denne difference er under 1 sekund, vil der blive verificeret at systemet overholder ydeevne-grænsen for download af data-objekter fra Databasen, hvilket resulterer i at systemet vil bestå dette krav.

Testen udføres, hvor server-delen af KMR systemet kører på Serveren, der er defineret som Rasbperry Pi 3b. "DataDownload\_test.py" scriptet bliver kørt på en PC som er på samme netværk som Serveren: "KMR\_NETWORK".

\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{1.0 cm}  p{4.5 cm}   p{4.5 cm}   c  }
		\multicolumn{4}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries Krav (8.4) - Systemet skal kunne håndtere download af 5 data-objekter i sekundet} \\
		\kravHeaderStyle
		Punkt & Test procedure & Forventet resultat & Godkendt?\\
		
		1 & Kør "DataDownload\_test.py" med Python 3.7 & Konsollen udskriver: \newline "Data upload test: ACCEPTED" & \vtop{\hbox{\strut [ \hspace*{0.1cm} ] Ja}\hbox{\strut }\hbox{\strut [ \hspace*{0.1cm} ] Nej}} \\
		
	\end{tabu}
	\caption{Yderligere krav - Download ydeevne}
	\label{tab:acceptest_yderligere_krav_download_ydeevne}
\end{table}

Herunder i figur \ref{fig:krav_8_4_datadownload} ses resultatet for testen af krav (8.4). Hermed kan det konkluderes at systemet uden problemer kan håndtere upload af 5 pakker i sekundet.

\begin{figure}[H]
	\centering{}
	\fbox{\includegraphics[width = 370 pt]{img/7_test/yderligere_krav_8_4_datadownload.png}}
	\caption{Test af krav 8.4 - Resultat}
	\label{fig:krav_8_4_datadownload}
\end{figure}

\pagebreak

\textbf{Test af krav 9.1} \\
I testen af krav (9.1) i tabel \ref{tab:acceptest_yderligere_krav_visualisering_af_data} vil der blive testet for hvorvidt systemet kan hente 50 data-objekter fra Databasen og visualisere disse for brugeren - på maksimum 2 sekunder. \newline

Testen udføres ved at tilgå KMR systemets hjemmeside og bruge Network-fanen i Google Chromes udviklerværktøj. Når man har denne fremme og er klar til at optage netværksaktiviteten på hjemmesiden, så genindlæser man siden og stopper straks optagelsen efter det første "document" er modtaget af KMR systemets hjemmeside. Denne del udføres ligesom integrationsteste af Presentation-subsystemet.
Efter at optagelsen er stoppet verificeres der først og fremmest om der er blevet indlæst 50 data-objekter på siden. Herefter verificeres der at alt hjemmeside indhold inklusiv data-objekter indlæses og præsenteres på under 2 sekunder.

Testen udføres, hvor server-delen af KMR systemet kører på Serveren, som er defineret som Rasbperry Pi 3b. KMR systemets hjemmeside bliver åbnet på PC'en der bruges til test, som er på samme netværk som Serveren: "KMR\_NETWORK".


\begin{table}[H]
	\renewcommand{\arraystretch}{2}
	\centering
	\sffamily
	\small
	\taburowcolors[2] 2{tableLineOne .. tableLineTwo}
	\tabulinesep = ^4mm_3mm
	\begin{tabu}{ p{1.0 cm}  p{4.5 cm}   p{4.5 cm}   c  }
		\multicolumn{4}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries Krav (9.1) - Systemet skal kunne hente minimum 50 data-objekter fra Databasen og} \\
		\multicolumn{4}{c}{\cellcolor{kravTitleHeader}\color{white}\bfseries fremvise dem for brugeren på under to sekunder.} \\
		\kravHeaderStyle
		Punkt & Test procedure & Forventet resultat & Godkendt?\\
		
		1 & Indlæs KMR systemets hjemmeside og følg guiden i teksten over denne tabel, samt de deskriptive  billeder: \ref{fig:yderlige_test_ydeevne_visualisering_hjemmeside_50_objekter} og \ref{fig:yderlige_test_ydeevne_visualisering_document_time} &  Under 2 sekunder & \vtop{\hbox{\strut [ \hspace*{0.1cm} ] Ja}\hbox{\strut }\hbox{\strut [ \hspace*{0.1cm} ] Nej}} \\
		
	\end{tabu}
	\caption{Yderligere krav - Ydeevne for visualisering af data}
	\label{tab:acceptest_yderligere_krav_visualisering_af_data}
\end{table}

Herunder i figur \ref{fig:yderlige_test_ydeevne_visualisering_hjemmeside_50_objekter} kan det ses, hvorhenne på KMR systemets hjemmeside man kan verificere antallet af viste data-objekter.

\begin{figure}[H]
	\centering
	\includegraphics[width = 300 pt]{img/7_test/yderlige_test_visualisering_hjemmeside.png}
	\caption[Test af krav 9.1 - Resultat]{Yderligere test - Ydeevne for visualisering af data - Visualisering af 50 data-objekter}
	\label{fig:yderlige_test_ydeevne_visualisering_hjemmeside_50_objekter}
\end{figure}

Herunder i figur \ref{fig:yderlige_test_ydeevne_visualisering_document_time} kan det ses, hvorhenne man kan verificere den totale indlæsnings tid på hjemmesiden, hvilket også er den totale tid for visualiseringen af data-objekterne for testen i tabel \ref{tab:acceptest_yderligere_krav_visualisering_af_data}.

\begin{figure}[H]
	\centering
	\includegraphics[width = 370 pt]{img/7_test/yderlige_test_visualisering_document_time.png}
	\caption[Test af krav 9.1 - Resultat (loadingtid)]{Yderligere test - Ydeevne for visualisering af data - Total tid brugt på visualisering}
	\label{fig:yderlige_test_ydeevne_visualisering_document_time}
\end{figure}

\chapter{Filstrukturering} \label{appendix::filstruktur}
I forbindelse med implementeringen af koden er der oprettet en struktur for de filer der indeholder KMR koden. Strukturen er lavet således denne afspejler det design der er lavet for KMR systemet. Det yderste led i strukturen indeholder to mapper, henholdsvis Distributioner og Tests. Distributioner indeholder den reelle kode mes test indeholder samtlige af de udførte KMR tests. Distributionsmappen indeholde både en Windows mappe og en Linux mappe. Dette er gjort, idet den fil struktur der findes for de to styresystemer, ikke er ens, hvorfor også koden ikke er ens. Linux koden anvendes i den distribuerede udgave af systemet, hvor server siden hostes på Raspberry Pi'en. 

I de to distributioner kan der findes en mappe for hvert af subsystemerne der findes for KMR systemet. Disse subsystemsmapper vil hver indeholde en klasse definition af de klasser der er identificeret i design processen. Test mappen vil indeholde mapper til henholdsvis de udviklings og accepttests der er lavet til KMR systemet. En visualisering af kodestrukturen kan ses af figur \ref{fig:code_structure}, hvor Pycharm er brugt til visualiseringen.

\begin{figure}[H]
	\centering
	\includegraphics[width = 225 pt]{img/9_Appendices/kodestruktur.png}
	\caption{Kodestruktur for KMR systemet}
	\label{fig:code_structure}
\end{figure}

\end{appendices}




